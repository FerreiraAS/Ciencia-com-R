# **Modelos** {#modelos}

<br>

## Modelos

<br>

### O que são modelos?

-   Modelos são representações simplificadas de um sistema real, usados para entender, prever ou controlar fenômenos complexos.[@REF]

<br>

### O que é modelagem?

-   Modelagem é o processo de usar dados para selecionar um modelo matemático explícito que represente o processo gerador dos dados.[@Greenland1989]

<br>

### Por que a escolha do modelo é complexa?

-   Há inúmeras combinações possíveis de variáveis, formas funcionais (lineares, quadráticas, transformações), interações e formas do desfecho, o que torna o espaço de possibilidades muito amplo.[@Greenland1989]

-   Todos os modelos são errados, mas alguns são úteis.[@box1976]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *equatiomatic*[@equatiomatic] fornece a função [*extract_eq*](https://www.rdocumentation.org/packages/equatiomatic/versions/0.3.1/topics/extract_eq) para extrair a equação dos modelos em formato LaTeX para visualização.
:::

<br>

### O que diferencia modelos clássicos e modernos em predição?

-   Modelos clássicos, como a regressão logística e as árvores de decisão, contrastam com os modelos modernos, como máquinas de vetor de suporte, redes neurais e *random forests* , principalmente pela maior flexibilidade e capacidade destes últimos de capturar não linearidades e interações.[@vanderploeg2014]

<br>

## Modelos estocásticos

<br>

### O que são modelos estocásticos?

-   .[@REF]

<br>

### O que são cadeias de Markov?

-   As cadeias de Markov descrevem processos em que o estado futuro depende apenas do estado presente, e não da trajetória passada.[@häggström2007]

<br>

```{r markov, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Cadeia de Markov com 3 estados (a, b, c) e suas probabilidades de transição."}
library(markovchain)

# --- Modelo de 3 estados (a, b, c) ---
estados <- c("a","b","c")
P <- matrix(c(0.5, 0.4, 0.1,
              0.2, 0.6, 0.2,
              0.3, 0.3, 0.4),
            nrow = 3, byrow = TRUE,
            dimnames = list(estados, estados))

# Criando a cadeia de Markov
mc <- new("markovchain",
          states = estados,
          transitionMatrix = P,
          name = "MC_3Estados")

# --- Gráfico com setas (usa plot do próprio pacote) ---
markovchain::plot(mc, 
                  vertex.size = 40,
                  vertex.label.cex = 1.5
)
```

<br>

```{r markov-sim, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Trajetória de estados e proporção acumulada por estado em uma cadeia de Markov com 3 estados (a, b, c)."}
# --- Modelo de 3 estados (a, b, c) ---
estados <- c("a","b","c")
P <- base::matrix(c(0.5, 0.4, 0.1,
                    0.2, 0.6, 0.2,
                    0.3, 0.3, 0.4),
                  nrow = 3, byrow = TRUE,
                  dimnames = list(estados, estados))

# Criando a cadeia de Markov (S4)
mc <- methods::new("markovchain",
                   states = estados,
                   transitionMatrix = P,
                   name = "MC_3Estados")

# --- Simulação da cadeia ao longo do tempo ---
base::set.seed(123)
n_passos <- 200

traj <- markovchain::markovchainSequence(
  n = n_passos,
  markovchain = mc,
  t0 = "a",
  include = TRUE
)

tempo <- 0:n_passos
estados_niveis <- mc@states
y <- base::match(traj, estados_niveis)

# --- Dados para gráfico 1 (trajetória) ---
df_traj <- base::data.frame(
  tempo = tempo,
  estado = base::match(traj, estados_niveis)  # numérico 1,2,3
)

# --- Dados para gráfico 2 (proporção acumulada) ---
df_prop <- base::data.frame(
  tempo = tempo,
  a = base::cumsum(traj == "a") / (tempo + 1),
  b = base::cumsum(traj == "b") / (tempo + 1),
  c = base::cumsum(traj == "c") / (tempo + 1)
)

df_prop_long <- tidyr::pivot_longer(
  df_prop,
  cols = -tempo,
  names_to = "estado",
  values_to = "proporcao"
)

g1 <- ggplot2::ggplot(df_traj,
                      ggplot2::aes(x = tempo, y = estado)) +
  ggplot2::geom_step(linewidth = 1, color = "steelblue") +
  ggplot2::scale_y_continuous(
    breaks = 1:base::length(estados_niveis),
    labels = estados_niveis
  ) +
  ggplot2::theme_minimal(base_size = 14) +
  ggplot2::labs(title = "Trajetória de Estados",
                x = "Tempo (passos)", y = "Estado")

g2 <- ggplot2::ggplot(df_prop_long,
                      ggplot2::aes(x = tempo, y = proporcao, group = estado)) +
  ggplot2::geom_line(linewidth = 1) +
  ggplot2::theme_minimal(base_size = 14) +
  ggplot2::labs(title = "Proporção Acumulada por Estado",
                x = "Tempo (passos)", y = "Proporção") +
  ggplot2::ylim(0, 1)

# --- Combinar em dois painéis (superior e inferior) ---
patchwork::wrap_plots(g1, g2, ncol = 1)
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *markovchain*[@markovchain] fornece a função [*markovchainFit*](https://www.rdocumentation.org/packages/markovchain/versions/0.9.5/topics/createSequenceMatrix) ajusta uma cadeia com base em dados observados.
:::

<br>

## Preditores e desfechos

<br>

### O que são desfechos de um modelo?

-   .[@REF]

<br>

### O que são preditores de um modelo?

-   .[@REF]

<br>

### Como selecionar preditores para um modelo?

-   .[@REF]

<br>

## Suposições dos modelos

<br>

### Quais suposições são feitas para modelagem?

-   .[@REF]

<br>

### Como avaliar as suposições de um modelo?

-   .[@REF]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *performance*[@performance] fornece a função [*check_model*](https://www.rdocumentation.org/packages/performance/versions/0.10.4/topics/check_model) para analisar a colinearidade entre variáveis, a normalidade da distribuição das variáveis e a heteroscedasticidade.
:::

<br>

## Fome de dados

<br>

### O que significa "fome de dados"?

- *Data hungry* descreve a necessidade de um modelo contar com muitos eventos por variável (EPV) para alcançar estabilidade estatística.

- Enquanto a regressão logística (LR) atinge desempenho estável com cerca de **20–50 EPV**, modelos como random forest (RF), redes neurais (NN) e máquinas de vetor de suporte (SVM) podem demandar **>200 EPV** para reduzir o otimismo e estabilizar a AUC.

<br>

### Por que a "fome de dados" é relevante?

- Em bases de dados pequenas, modelos clássicos tendem a ser mais robustos e menos suscetíveis a superajuste.[@vanderploeg2014]

- O uso de modelos modernos só se justifica quando há grandes bases de dados, caso contrário o ganho em acurácia é marginal.[@vanderploeg2014]

- Esse conceito conecta diretamente a escolha do modelo ao planejamento amostral.[@vanderploeg2014]

<br>

## Desempenho e estabilidade de modelos

<br>

### Como avaliar o desempenho dos modelos?

- Pela área sob a curva ROC em conjunto com o otimismo (diferença entre AUC aparente e validada).[@vanderploeg2014]

- O desempenho melhora com maior tamanho amostral, mas de forma desigual entre técnicas.[@vanderploeg2014]

<br>

### Qual modelo alcança estabilidade mais rapidamente?

- Regressão logística é o mais estável e menos *data hungry*.[@vanderploeg2014]

- Árvore de decisão para classificação e regressão estabiliza rápido, mas em nível de desempenho baixo.[@vanderploeg2014]

- Máquina de vetores de suporte, redes neurais e *random forests* apresentam instabilidade mesmo em amostras muito grandes.[@vanderploeg2014]

<br>

## Avaliação de modelos

<br>

### Como avaliar a qualidade de ajuste de um modelo?

-   Coeficiente de determinação ($R^2$) e $R^2$ ajustado: Medem a proporção da variabilidade dos dados explicada pelo modelo. O $R^2$ ajustado penaliza a inclusão de variáveis irrelevantes.[@REF]

<br>

```{r r2-ajuste, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Exemplos de ajuste de modelos de regressão linear simples (y ~ x) com diferentes níveis de ruído (R²). Cada painel mostra a reta ajustada (cinza) e os valores observados (pontos). Os valores anotados indicam o coeficiente angular simulado (β), o coeficiente angular estimado (β̂) e o R² observado.", out.width = "100%"}
# Reprodutibilidade
base::set.seed(123)

# Parâmetros
n          <- 150
beta_true  <- 1.0                  # Inclinação verdadeira (simulada)
r2_targets <- c(0.85, 0.50, 0.15)  # Níveis com ruído

# Gera x comum e sinal verdadeiro (sem intercepto)
x   <- stats::rnorm(n, mean = 0, sd = 1)
y_s <- beta_true * x
var_signal <- stats::var(y_s)

# Função para adicionar ruído baseado no R² alvo (usa variância amostral do sinal)
build_df <- function(R2_target) {
  se <- sqrt((1 - R2_target) / R2_target * var_signal)
  y  <- y_s + stats::rnorm(n, mean = 0, sd = se)
  data.frame(x = x, y = y, grupo = sprintf("ruido_%.2f", R2_target), alvo = R2_target)
}

# Data frames com ruído
dfs_ruido <- lapply(r2_targets, build_df)
df_ruido  <- base::do.call(base::rbind, dfs_ruido)

# Data frame perfeito (sem ruído)
df_perfeito <- data.frame(x = x, y = y_s, grupo = "perfeito", alvo = 1.00)

# Combina e define ordem dos painéis (perfeito primeiro)
layout_df <- base::rbind(df_perfeito, df_ruido)
layout_df$grupo <- factor(layout_df$grupo, levels = c("perfeito", sprintf("ruido_%.2f", r2_targets)))

# Ajusta lm(y ~ x) por grupo para anotar β̂ e R² observado
obs <- do.call(rbind, lapply(split(layout_df, layout_df$grupo), function(dd) {
  fit <- stats::lm(y ~ x, data = dd)
  R2  <- summary(fit)$r.squared
  data.frame(
    grupo    = dd$grupo[1],
    beta_hat = unname(coef(fit)[["x"]]),
    R2_obs   = R2
  )
}))

# Rótulos dos painéis: β simulado | β̂ | R²
make_label <- function(g, b_true, b_hat, r2) {
  titulo <- if (g == "perfeito") "Perfeita (sem ruído)" else "Com ruído"
  sprintf("%s\nβ simulado = %.2f | β̂ = %.2f | R² = %.2f",
          titulo, b_true, b_hat, r2)
}

obs$label <- mapply(make_label, as.character(obs$grupo),
                    MoreArgs = list(b_true = beta_true),
                    b_hat = obs$beta_hat, r2 = obs$R2_obs)

# Junta o rótulo ao DF para facetar
layout_df <- merge(layout_df, obs[, c("grupo","label")], by = "grupo", all.x = TRUE)

# Plot
ggplot2::ggplot(layout_df, ggplot2::aes(x = x, y = y)) +
  ggplot2::geom_point(alpha = 0.7) +
  ggplot2::geom_smooth(method = "lm", se = FALSE, color = "gray40") +
  ggplot2::facet_wrap(~ label, nrow = 1) +
  ggplot2::labs(x = "X", y = "Y") +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.line        = ggplot2::element_line(color = "black"),
    aspect.ratio     = 1,
    panel.spacing    = grid::unit(0.6, "lines"),
    strip.text       = ggplot2::element_text(face = "bold"),
    plot.margin      = ggplot2::margin(10, 5, 10, 5)
  )
```

-   Erro quadrático médio ($RMSE$): Mede a média dos erros ao quadrado entre os valores observados e os valores previstos pelo modelo. Valores menores indicam melhor ajuste.[@REF]

-   Critério de Informação Akaike ($AIC$) e Critério de Informação Bayesiano ($BIC$): Avaliam o ajuste do modelo penalizando a complexidade (número de parâmetros). Modelos com menor AIC ou BIC são preferíveis.[@REF]

-   Desvio residual ($\sigma$): Mede a variabilidade dos resíduos do modelo. Valores menores indicam melhor ajuste.[@REF]

<br>

```{r metricas-ajuste, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, results = "asis"}
# Reprodutibilidade
set.seed(123)

# Modelo
dados <- data.frame(x = rnorm(100, 5, 2),
                    y = 3 + 1.5 * rnorm(100, 5, 2) + rnorm(100))
modelo <- lm(y ~ x, data = dados)

# Resultado
resultado <- performance::model_performance(modelo)

# Reestruturando para exibir como "Métrica | Valor"
resultado_df <- as.data.frame(t(resultado)) # transpor para linhas
resultado_df$Métrica <- rownames(resultado_df)
colnames(resultado_df)[1] <- "Valor"
rownames(resultado_df) <- NULL
resultado_df <- resultado_df[, c("Métrica", "Valor")]

# Formatando os valores numéricos
resultado_df$Valor <- formatC(
  resultado_df$Valor,
  format = "f",
  digits = 3,
  big.mark = ",",
  decimal.mark = "."
)

resultado_df$Métrica <- dplyr::recode(
  resultado_df$Métrica,
  AIC = "AIC",
  AICc = "AIC corrigido",
  BIC = "BIC",
  R2 = "$R^2$",
  R2_adjusted = "$R^2$ ajustado",
  RMSE = "Erro quadrático médio (RMSE)",
  Sigma = "Desvio residual (sigma)"
)

# Exibindo com estilo avançado
kableExtra::kable(
  resultado_df,
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  escape = FALSE,
  caption = "Métricas de desempenho do modelo de regressão linear."
) %>%
  kableExtra::kable_styling(
    latex_options = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), TRUE, TRUE),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::row_spec(nrow(resultado_df), extra_css = "border-bottom: 1px solid")
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *performance*[@performance] fornece a função [*model_performance*](https://www.rdocumentation.org/packages/performance/versions/0.10.4/topics/model_performance) para calcular as métricas de ajuste da regressão adequadas ao modelo pré-especificado.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *performance*[@performance] fornece a função [*compare_performance*](https://www.rdocumentation.org/packages/performance/versions/0.10.4/topics/compare_performance) para comparar o desempenho e a qualidade do ajuste de diversos modelos de regressão pré-especificados.
:::

<br>

## Validação de modelos

<br>

### Como validar modelos estatísticos?

-   .[@REF]

<br>

## Calibração de modelos

<br>

### Como calibrar modelos estatísticos?

-   .[@REF]

<br>

## Comparação de modelos

<br>

### Como comparar modelos de aprendizagem de máquina?

-   .[@REF]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *correctR*[@correctR] fornece funções para comparar o desempenho e a qualidade do ajuste de diversos modelos de aprendizagem de máquina em amostras correlacionadas.
:::

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
