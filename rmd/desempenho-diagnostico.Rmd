# **Desempenho diagnóstico** {#desempenho-diagnostico}

<br>

## Características

<br>

### Quais são as características de estudos de desempenho diagnóstico?

-   .[@REF]

<br>

## Tabelas 2x2

<br>

### O que é uma tabela de confusão 2x2?

-   Tabela de confusão é uma matriz de 2 linhas por 2 colunas que permite analisar o desempenho de classificação de uma variável dicotômica (padrão-ouro ou referência) versus outra variável dicotômica (novo teste).[@steckelberg2004]

<br>

### Como analisar o desempenho diagnóstico em tabelas 2x2?

-   Verdadeiro-positivo ($VP$): caso com a condição presente e corretamente identificado como tal.[@greenhalgh1997b]

-   Falso-negativo ($FN$): caso com a condição presente e erroneamente identificado como ausente.[@greenhalgh1997b]

-   Verdadeiro-negativo ($VN$): controle sem a condição presente e corretamente identificados como tal.[@greenhalgh1997b]

-   Falso-positivo ($FP$): controle sem a condição presente e erroneamente identificado como presente.[@greenhalgh1997b]

<br>

```{r crosstable, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
library(dplyr)

cross.table <-
  matrix(
    c(
      '$VP$',
      '$FN$',
      '$VP+FN$',
      '$FP$',
      '$VN$',
      '$FP+VN$',
      '$VP+FP$',
      '$FN+VN$',
      '$N=VP+VN+FP+FN$'
    ),
    nrow = 3,
    ncol = 3,
    byrow = FALSE
  )
rownames(cross.table) <-
  c("Teste positivo", "Teste negativo", "Total")
colnames(cross.table) <-
  c("Condição presente", "Condição ausente", "Total")

# exibe a tabela de dados
kableExtra::kable(
  cross.table,
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  escape = FALSE,
  caption = "Tabela de confusão 2x2 para análise de desempenho diagnóstico de testes e variáveis dicotômicas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec((dim(cross.table)[1] - 1), bold = TRUE, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::row_spec(dim(cross.table)[1], extra_css = "border-bottom: 1px solid")
```

<br>

-   Tabelas de confusão também podem ser visualizadas em formato de árvores de frequência.[@steckelberg2004]

```{r frequency-tree, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Árvore de frequência do desempenho diagnóstico de uma tabela de confusão 2x2 representando um método novo (dicotômico) comparado ao método padrão-ouro ou referência (dicotômico)."}
# generate data
gold.std <- rbinom(n = 100, size = 1, prob = 0.5)
new.test <- rbinom(n = 100, size = 1, prob = 0.5)
dataset <- data.frame("Padrão-ouro" = gold.std, "Novo teste" = new.test)

# change labels
my_txt <-
  riskyr::init_txt(
    cond_lbl = "Padrão-ouro",
    cond_true_lbl = "Presente",
    cond_false_lbl = "Ausente",
    hi_lbl = "VP",
    mi_lbl = "FN",
    fa_lbl = "FP",
    cr_lbl = "VN"
  )

# plot the frequency tree
riskyr::plot_prism(
  dataset,
  by = "cd",
  show_accu = TRUE,
  main = NULL,
  sub = NULL,
  col_pal = riskyr::pal_bw,
  f_lbl = "nam",
  p_lbl = "no",
  lbl_txt = my_txt,
  f_lwd = .5
)
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *riskyr*[@riskyr] fornece a função [*plot_prism*](https://www.rdocumentation.org/packages/riskyr/versions/0.4.0/topics/plot_prism) para construir árvores de frequência a partir de diferentes cenários.
:::

<br>

### Quais probabilidades caracterizam o desempenho diagnóstico de um teste em tabelas 2x2?

-   Sensibilidade ($SEN$), equação \@ref(eq:sen): Proporção de verdadeiro-positivos dentre aqueles com a condição.[@greenhalgh1997b]

\begin{equation}
(\#eq:sen)
SEN = \dfrac{VP}{VP+FN}
\end{equation}

-   Especificidade ($ESP$), equação \@ref(eq:esp): Proporção de verdadeiro-negativos dentre aqueles sem a condição.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:esp)
ESP = \dfrac{VN}{VN+FP}
\end{equation}

<br>

```{r sensibilidade-especificidade, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Trade-off entre sensibilidade e especificidade em função do limiar de probabilidade (t) para um modelo de classificação."}
# ---- Parâmetros dos grupos (ajuste à sua realidade) ----
# "doente": previsões tendem a ser altas
alpha_d   <- 9;  beta_d   <- 3   # média ≈ 0.75
# "não-doente": previsões tendem a ser baixas
alpha_nd  <- 3;  beta_nd  <- 9   # média ≈ 0.25

# ---- Grade de limiares (probabilidade no eixo x) ----
t <- seq(0, 1, length.out = 1001)

# ---- Curvas: Sensibilidade(t) e Especificidade(t) ----
sens <- 1 - pbeta(t, shape1 = alpha_d,  shape2 = beta_d)   # P(score >= t | doente)
spec <-     pbeta(t, shape1 = alpha_nd, shape2 = beta_nd)  # P(score <  t | não-doente)

df <- tibble::tibble(
  threshold = t,
  Sensibilidade = sens,
  Especificidade = spec,
  Youden = sens + spec - 1
)

# ---- Limiar ótimo (Youden J) ----
opt <- df |>  dplyr::slice_max(Youden, n = 1)

# ---- Plot ----
ggplot2::ggplot(df, ggplot2::aes(x = threshold)) +
  ggplot2::geom_line(ggplot2::aes(y = Sensibilidade), linewidth = 1) +
  ggplot2::geom_line(ggplot2::aes(y = Especificidade), linetype = 2, linewidth = 1) +
  ggplot2::geom_vline(xintercept = opt$threshold, linetype = 3) +
  ggplot2::annotate("point", x = opt$threshold, y = 0.5*(opt$Sensibilidade + opt$Especificidade), size = 2) +
  ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0,1)) +
  ggplot2::labs(
    x = "Limiar de probabilidade (t)",
    y = "Proporção de casos corretamente identificados",
    title = "Trade-off entre Sensibilidade e Especificidade",
    subtitle = sprintf("Limiar de Youden ≈ %.1f%% | Sens=%.1f%%, Esp=%.1f%%",
                       100*opt$threshold, 100*opt$Sensibilidade, 100*opt$Especificidade),
    caption = "Linhas: sólida = Sensibilidade; tracejada = Especificidade"
  ) +
  ggplot2::theme_minimal(base_size = 12)
```

<br>

-   Valor preditivo positivo ($VPP$), equação \@ref(eq:vpp): Proporção de casos corretamente identificados como verdadeiro-positivos.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:vpp)
VPP = \dfrac{VP}{VP+FP}
\end{equation}

<br>

-   Valor preditivo negativo ($VPN$), equação \@ref(eq:vpn): Proporção de controles corretamente identificados como verdadeiro-negativos.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:vpn)
VPN = \dfrac{VN}{VN+FN}
\end{equation}

<br>

-   Acurácia ($ACU$), equação \@ref(eq:acu): Proporção de casos e controle corretamente identificados.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:acu)
ACU = \dfrac{VP+VN}{VP+VN+FP+FN}
\end{equation}

<br>

-   Razão de chances diagnóstica ($DOR$), equação \@ref(eq:dor): Razão entre a chance de um teste ser positivo quando a condição está presente e a chance de um teste ser positivo quando a condição está ausente.[@Glas2003]

\begin{equation}
(\#eq:dor)
DOR = \dfrac{VP}{FN} \div \dfrac{FP}{VN} = \dfrac{VP \cdot VN}{FP \cdot FN}
\end{equation}

<br>

```{r crosstable-prob, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
library(dplyr)

cross.table <-
  matrix(
    c(
      '$VP$',
      '$FN$',
      '$VP+FN$',
      '$SEN = \\frac{VP}{VP+FN}$',
      '$FP$',
      '$VN$',
      '$FP+VN$',
      '$ESP = \\frac{VN}{VN+FP}$',
      '$VP+FP$',
      '$FN+VN$',
      '$N=VP+VN+FP+FN$',
      '',
      '$VPP = \\frac{VP}{VP+FP}$',
      '$VPN = \\frac{VN}{VN+FN}$',
      '',
      '$ACU = \\frac{VP+VN}{VP+VN+FP+FN}$ \\ $DOR = \\frac{VP \\cdot VN}{FP \\cdot FN}$'
    ),
    nrow = 4,
    ncol = 4,
    byrow = FALSE
  )

rownames(cross.table) <- c("Teste positivo", "Teste negativo", "Total", "Probabilidades")
colnames(cross.table) <- c("Condição presente",
                           "Condição ausente",
                           "Total",
                           "Probabilidades")

# exibe a tabela de dados
kableExtra::kable(
  cross.table,
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  escape = FALSE,
  caption = "Probabilidades calculados a partir da tabela de confusão 2x2 para análise de desempenho diagnóstico de testes e variáveis dicotômicas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec((dim(cross.table)[1] - 1), bold = TRUE, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::row_spec(dim(cross.table)[1], extra_css = "border-bottom: 1px solid")
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *riskyr*[@riskyr] fornece a função [*comp_prob*](https://www.rdocumentation.org/packages/riskyr/versions/0.4.0/topics/comp_prob) para estimar 13 probabilidades relacionadas ao desempenho diagnóstico em tabelas 2x2.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *caret*[@caret] fornece a função [*confusionMatrix*](https://www.rdocumentation.org/packages/caret/versions/3.45/topics/confusionMatrix) para estimar 11 probabilidades relacionadas ao desempenho diagnóstico em tabelas 2x2.
:::

<br>

## Curvas ROC

<br>

### O que representa a curva ROC?

-   A relação entre sensibilidade ($SEN$) no eixo vertical e $1 - ESP$ no eixo horizontal.[@he2024]

-   Cada ponto na curva corresponde a um ponto de corte possível do teste.[@he2024]

<br>

### Quais são os tipos de curva ROC?

-   Curva empírica: conecta diretamente os pontos obtidos a partir dos diferentes pontos de corte observados.[@park2004]

-   Curva suavizada (paramétrica): assume uma distribuição binormal e gera uma curva ajustada por máxima verossimilhança.[@park2004]

<br>

### Como definir o melhor ponto de corte?

-   O ponto de corte em uma curva ROC representa um balanço entre sensibilidade e especificidade, ou seja, a taxa de verdadeiros positivos e a taxa de falsos positivos.[@he2024; @park2004]

-   O método de Youden (equação \@ref(eq:youden) maximiza maximiza a diferença entre a taxa de verdadeiros positivos e a taxa de falsos positivos. O ponto de corte ideal será aquele com maior valor de $Y$.[@YOUDEN1950]

\begin{equation}
(\#eq:youden)
Y = SEN + ESP - 1
\end{equation}

-   O método da distância Euclidiana (\@ref(eq:euclidean) minimiza a distância entre um ponto da curva ROC e o ponto (0,1), que representa sensibilidade perfeita ($SEN = 100%$) e especificidade perfeita ($ESP = 100%$). O ponto de corte ideal será aquele com menor valor de $D$.[@yarnold2014]

\begin{equation}
(\#eq:euclidean)
D = \sqrt{(1 - SEN)^2 + (1 - ESP)^2}
\end{equation}

<br>

### O que é a área sob a curva (AUROC)?

-   A área sob a curva ROC (AUC ou AUROC) quantifica o poder de discriminação ou desempenho diagnóstico na classificação de uma variável dicotômica.[@de2022]

-   A área sob a curva ($AUC$) resume o desempenho global e representa a probabilidade de o teste classificar corretamente um caso positivo selecionado aleatoriamente em relação a um caso negativo selecionado aleatoriamente.[@he2024]

<br>

### Como calcular a AUC?

-   Método não paramétrico: soma das áreas trapezoidais sob a curva empírica. Pode subestimar AUC quando os dados são discretos.[@park2004]

-   Método paramétrico (binormal): mais robusto para dados em escala ordinal (ex: categorias diagnósticas), com viés reduzido.[@park2004]

-   AUC deve sempre vir acompanhada de intervalo de confiança (IC95%).[@park2004]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *proc*[@pROC] fornece a função [*plot.roc*](https://www.rdocumentation.org/packages/pROC/versions/1.18.4/topics/plot.roc) para criar uma curva ROC.
:::

<br>

### Como interpretar a área sob a curva (ROC)?

-   A área sob a curva AUC varia no intervalo $[0.5; 1]$, com valores mais elevados indicando melhor discriminação ou desempenho do modelo de classificação.[@de2022]

-   As interpretações qualitativas (isto é: pobre/fraca/baixa, moderada/razoável/aceitável, boa ou muito boa/alta/excelente) dos valores de área sob a curva são arbitrários e não devem ser considerados isoladamente.[@de2022]

-   Modelos de classificação com valores altos de área sob a curva podem ser enganosos se os valores preditos por esses modelos não estiverem adequadamente calibrados.[@de2022]

-   Diferenças pequenas entre AUCs podem não ser estatisticamente significativas.[@he2024]

-   A interpretação clínica pode ser equivocada se não houver teste estatístico adequado.[@he2024]

-   Se as curvas vêm do mesmo conjunto de pacientes, aplique o teste de DeLong.[@he2024]

-   Se as curvas vêm de amostras independentes, use métodos como Dorfman-Alf.[@he2024]

<br>

### Por que uma AUC menor que 0.5 está errada?

-   Porque indica desempenho pior que o acaso.[@he2024]

-   Geralmente decorre de seleção incorreta da direção do teste ou variável de estado.[@he2024]

-   Verifique se o software está configurado para maiores valores indicam presença do evento ou o inverso.[@he2024]

-   Ajustar a direção do teste para que $AUC ≥ 0.5$.[@he2024]

<br>

```{r roc, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Curva ROC (Receiver Operating Characteristic) para um modelos de classificação com diferentes desempenhos diagnósticos."}
# reproduzível
set.seed(123)

# AUC alvo -> d' (duas Normais com mesma variância: AUC = Phi(d'/sqrt(2)))
dprime_from_auc <- function(target_auc) sqrt(2) * stats::qnorm(target_auc)

simulate_scores <- function(n_pos = 1000, n_neg = 1000, target_auc = 0.75) {
  dprime <- dprime_from_auc(target_auc)
  scores_neg <- stats::rnorm(n_neg, mean = 0, sd = 1)
  scores_pos <- stats::rnorm(n_pos, mean = dprime, sd = 1)
  tibble::tibble(
    y = c(rep(0L, n_neg), rep(1L, n_pos)),
    score = c(scores_neg, scores_pos)
  )
}

threshold_metrics <- function(df, thr) {
  y <- df$y
  pred <- as.integer(df$score >= thr)
  TP <- sum(pred == 1 & y == 1)
  FP <- sum(pred == 1 & y == 0)
  TN <- sum(pred == 0 & y == 0)
  FN <- sum(pred == 0 & y == 1)

  sens <- ifelse((TP + FN) > 0, TP / (TP + FN), NA_real_)
  spec <- ifelse((TN + FP) > 0, TN / (TN + FP), NA_real_)
  ppv  <- ifelse((TP + FP) > 0, TP / (TP + FP), NA_real_)
  npv  <- ifelse((TN + FN) > 0, TN / (TN + FN), NA_real_)
  acc  <- (TP + TN) / (TP + TN + FP + FN)
  f1   <- ifelse((2*TP + FP + FN) > 0, 2*TP / (2*TP + FP + FN), NA_real_)

  tibble::tibble(
    threshold = thr,
    TP = TP, FP = FP, TN = TN, FN = FN,
    Sensitivity = sens, Specificity = spec,
    PPV = ppv, NPV = npv, Accuracy = acc, F1 = f1
  )
}

build_roc_summary <- function(df, label_auc) {
  # Primeiro tenta com direction=">"
  roc_obj <- pROC::roc(
    response  = factor(df$y, levels = c(0,1)),
    predictor = df$score,
    quiet     = TRUE,
    direction = ">"
  )
  # Se por qualquer motivo ficar < 0.5, recalcula invertendo
  if (as.numeric(pROC::auc(roc_obj)) < 0.5) {
    roc_obj <- pROC::roc(
      response  = factor(df$y, levels = c(0,1)),
      predictor = df$score,
      quiet     = TRUE,
      direction = "<"
    )
  }

  # Cutoffs
  youden <- pROC::coords(
    roc_obj, x = "best", best.method = "youden",
    ret = c("threshold","sensitivity","specificity"), transpose = FALSE
  )
  euclid <- pROC::coords(
    roc_obj, x = "best", best.method = "closest.topleft",
    ret = c("threshold","sensitivity","specificity"), transpose = FALSE
  )

  met_youden <- threshold_metrics(df, youden$threshold) |>
    dplyr::mutate(Cutoff = "Youden")
  met_euclid <- threshold_metrics(df, euclid$threshold) |>
    dplyr::mutate(Cutoff = "Euclidean")

  cut_table <- dplyr::bind_rows(
    tibble::tibble(Cutoff = "Youden",
      threshold = youden$threshold,
      Sensitivity = youden$sensitivity,
      Specificity = youden$specificity),
    tibble::tibble(Cutoff = "Euclidean",
      threshold = euclid$threshold,
      Sensitivity = euclid$sensitivity,
      Specificity = euclid$specificity)
  )

  list(
    auc_label   = label_auc,
    roc         = roc_obj,
    df          = df,
    coords_tbl  = cut_table,
    metrics_tbl = dplyr::bind_rows(met_youden, met_euclid)
  )
}

targets <- c(0.50, 0.75, 0.90)

data_list <- purrr::map(
  targets,
  ~{ d <- simulate_scores(n_pos = 1500, n_neg = 1500, target_auc = .x)
     build_roc_summary(d, label_auc = sprintf("AUC %.2f", .x)) }
)

cutoffs_tbl <- purrr::map_dfr(
  data_list,
  ~ .x$coords_tbl |>
    dplyr::mutate(Model = .x$auc_label) |>
    dplyr::relocate(Model, Cutoff)
)

metrics_tbl <- purrr::map_dfr(
  data_list,
  ~ .x$metrics_tbl |>
    dplyr::mutate(Model = .x$auc_label) |>
    dplyr::relocate(Model, Cutoff)
)

# --------- Curvas ROC (acima da diagonal) ----------
roc_df <- purrr::map_dfr(
  data_list,
  function(x) {
    gdat <- pROC::ggroc(x$roc)$data
    dplyr::mutate(gdat, Model = x$auc_label)
  }
)

cut_points <- cutoffs_tbl |>
  dplyr::mutate(FPR = 1 - Specificity,
                TPR = Sensitivity)

p <- ggplot2::ggplot() +
  ggplot2::geom_line(
    data = roc_df,
    ggplot2::aes(x = 1 - specificity, y = sensitivity, color = Model),
    linewidth = 1
  ) +
  ggplot2::geom_abline(
    intercept = 0, slope = 1,
    linewidth = 0.6, alpha = 0.6, linetype = "dashed"
  ) +
  ggplot2::geom_point(
    data = cut_points,
    ggplot2::aes(x = FPR, y = TPR, shape = Cutoff),
    size = 2.8
  ) +
  ggplot2::geom_hline(yintercept = 0, color = "black") +
  ggplot2::geom_vline(xintercept = 0, color = "black") +
  ggplot2::facet_wrap(~ Model) +
  ggplot2::labs(
    title = "Curva Característica de Operação do Receptor (Curva ROC)",
    x = "1 - Especificidade", y = "Sensibilidade",
    color = "Modelo", shape = "Cutoff"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::coord_equal(xlim = c(0,1), ylim = c(0,1)) +   # garante quadrado
  ggplot2::scale_x_continuous(limits = c(0,1), expand = c(0,0)) +
  ggplot2::scale_y_continuous(limits = c(0,1), expand = c(0,0))

print(p)
```

<br>

### Como analisar o desempenho diagnóstico em desfechos com distribuição trimodal na população?

-   Limiares duplos podem ser utilizados para análise de desempenho diagnóstico de testes com distribuição trimodal.[@ferreira2021]

<br>

## Gráficos *crosshair*

<br>

### O que um gráfico *crosshair*?

-   .[@phillips2010]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *mada*[@mada] fornece a função [*crosshair*](https://www.rdocumentation.org/packages/mada/versions/0.5.11/topics/crosshair) para criar um gráfico *crosshair*[@phillips2010] a partir de dados de verdadeiro-positivo, falso-positivo, verdadeiro-negativo e verdadeiro-positivo de tabelas de confusão 2x2.
:::

<br>

## Interpretação da validade de um teste

<br>

### Que itens devem ser verificados na interpretação de um estudo de validade?

-   O novo teste foi comparado junto ao método padrão-ouro.[@greenhalgh1997b]

-   As probabilidades pontuais estimadas que caracterizam o desempenho diagnóstico do novo teste são altas e adequadas para sua aplicação clínica.[@greenhalgh1997b]

-   Os intervalos de confiança estimados para as probabilidades do novo teste são estreitos e adequadas para sua aplicação clínica.[@greenhalgh1997b]

-   O novo teste possui adequada confiabilidade intra/inter examinadores.[@greenhalgh1997b]

-   O estudo de validação incluiu um espectro adequado da amostra.[@greenhalgh1997b]

-   Todos os participantes realizaram ambos o novo teste e o padrão-ouro no estudo de validação.[@greenhalgh1997b]

-   Os examinadores do novo teste estavam cegados para o resultado do teste padrão-ouro.[@greenhalgh1997b]

<br>

## Diretrizes para redação

<br>

### Quais são as diretrizes para redação de estudos diagnósticos?

-   Visite a rede *Enhancing the QUAlity and Transparency Of health Research* ([EQUATOR Network](https://www.equator-network.org/)) para encontrar diretrizes específicas para cada tipo de estudo de desempenho diagnóstico.

    -   *STARD 2015: An Updated List of Essential Items for Reporting Diagnostic Accuracy Studies*:[@bossuyt2015] <https://www.equator-network.org/reporting-guidelines/stard/>

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
