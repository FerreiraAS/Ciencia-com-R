# **Desempenho diagn√≥stico** {#desempenho-diagnostico}

<br>

## Caracter√≠sticas

<br>

### Quais s√£o as caracter√≠sticas de estudos de desempenho diagn√≥stico?

-   .[@REF]

<br>

## Tabelas 2x2

<br>

### O que √© uma tabela de confus√£o 2x2?

-   Tabela de confus√£o √© uma matriz de 2 linhas por 2 colunas que permite analisar o desempenho de classifica√ß√£o de uma vari√°vel dicot√¥mica (padr√£o-ouro ou refer√™ncia) versus outra vari√°vel dicot√¥mica (novo teste).[@steckelberg2004]

<br>

### Como analisar o desempenho diagn√≥stico em tabelas 2x2?

-   Verdadeiro-positivo ($VP$): caso com a condi√ß√£o presente e corretamente identificado como tal.[@greenhalgh1997b]

-   Falso-negativo ($FN$): caso com a condi√ß√£o presente e erroneamente identificado como ausente.[@greenhalgh1997b]

-   Verdadeiro-negativo ($VN$): controle sem a condi√ß√£o presente e corretamente identificados como tal.[@greenhalgh1997b]

-   Falso-positivo ($FP$): controle sem a condi√ß√£o presente e erroneamente identificado como presente.[@greenhalgh1997b]

<br>

```{r crosstable-2x2, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
library(dplyr)

cross.table <-
  matrix(
    c(
      '$VP$',
      '$FN$',
      '$VP+FN$',
      '$FP$',
      '$VN$',
      '$FP+VN$',
      '$VP+FP$',
      '$FN+VN$',
      '$N=VP+VN+FP+FN$'
    ),
    nrow = 3,
    ncol = 3,
    byrow = FALSE
  )
rownames(cross.table) <-
  c("Teste positivo", "Teste negativo", "Total")
colnames(cross.table) <-
  c("Condi√ß√£o presente", "Condi√ß√£o ausente", "Total")

# exibe a tabela de dados
kableExtra::kable(
  cross.table,
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  escape = FALSE,
  caption = "Tabela de confus√£o 2x2 para an√°lise de desempenho diagn√≥stico de testes e vari√°veis dicot√¥micas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec((dim(cross.table)[1] - 1), bold = TRUE, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::row_spec(dim(cross.table)[1], extra_css = "border-bottom: 1px solid")
```

<br>

-   Tabelas de confus√£o tamb√©m podem ser visualizadas em formato de √°rvores de frequ√™ncia.[@steckelberg2004]

```{r frequency-tree, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "√Årvore de frequ√™ncia do desempenho diagn√≥stico de uma tabela de confus√£o 2x2 representando um m√©todo novo (dicot√¥mico) comparado ao m√©todo padr√£o-ouro ou refer√™ncia (dicot√¥mico)."}
# Reprodutibilidade
set.seed(123)

# generate data
gold.std <- rbinom(n = 100, size = 1, prob = 0.5)
new.test <- rbinom(n = 100, size = 1, prob = 0.5)
dataset <- data.frame("Padr√£o-ouro" = gold.std, "Novo teste" = new.test)

# change labels
my_txt <-
  riskyr::init_txt(
    cond_lbl = "Padr√£o-ouro",
    cond_true_lbl = "Presente",
    cond_false_lbl = "Ausente",
    hi_lbl = "VP",
    mi_lbl = "FN",
    fa_lbl = "FP",
    cr_lbl = "VN"
  )

# plot the frequency tree
riskyr::plot_prism(
  dataset,
  by = "cd",
  show_accu = TRUE,
  main = NULL,
  sub = NULL,
  col_pal = riskyr::pal_bw,
  f_lbl = "nam",
  p_lbl = "no",
  lbl_txt = my_txt,
  f_lwd = .5
)
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *riskyr*[@riskyr] fornece a fun√ß√£o [*plot_prism*](https://www.rdocumentation.org/packages/riskyr/versions/0.4.0/topics/plot_prism) para construir √°rvores de frequ√™ncia a partir de diferentes cen√°rios.
:::

<br>

### Quais probabilidades caracterizam o desempenho diagn√≥stico de um teste em tabelas 2x2?

-   Sensibilidade ($SEN$) \@ref(eq:sen): Propor√ß√£o de verdadeiro-positivos dentre aqueles com a condi√ß√£o.[@greenhalgh1997b]

\begin{equation}
(\#eq:sen)
SEN = \dfrac{VP}{VP+FN}
\end{equation}

-   Especificidade ($ESP$) \@ref(eq:esp): Propor√ß√£o de verdadeiro-negativos dentre aqueles sem a condi√ß√£o.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:esp)
ESP = \dfrac{VN}{VN+FP}
\end{equation}

<br>

```{r sensibilidade-especificidade, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Trade-off entre sensibilidade e especificidade em fun√ß√£o do limiar de probabilidade (t) para um modelo de classifica√ß√£o."}
# ---- Par√¢metros dos grupos (ajuste √† sua realidade) ----
# "doente": previs√µes tendem a ser altas
alpha_d   <- 9;  beta_d   <- 3   # m√©dia ‚âà 0.75
# "n√£o-doente": previs√µes tendem a ser baixas
alpha_nd  <- 3;  beta_nd  <- 9   # m√©dia ‚âà 0.25

# ---- Grade de limiares (probabilidade no eixo x) ----
t <- seq(0, 1, length.out = 1001)

# ---- Curvas: Sensibilidade(t) e Especificidade(t) ----
sens <- 1 - pbeta(t, shape1 = alpha_d,  shape2 = beta_d)   # P(score >= t | doente)
spec <-     pbeta(t, shape1 = alpha_nd, shape2 = beta_nd)  # P(score <  t | n√£o-doente)

df <- tibble::tibble(
  threshold = t,
  Sensibilidade = sens,
  Especificidade = spec,
  Youden = sens + spec - 1
)

# ---- Limiar √≥timo (Youden J) ----
opt <- df |>  dplyr::slice_max(Youden, n = 1)

# Texto do r√≥tulo no ponto de Youden
lbl <- sprintf("t* = %.1f%%\nSens = %.1f%%\nEsp = %.1f%%",
               100*opt$threshold, 100*opt$Sensibilidade, 100*opt$Especificidade)

# ---- Plot ----
ggplot2::ggplot(df, ggplot2::aes(x = threshold)) +
  ggplot2::geom_line(ggplot2::aes(y = Sensibilidade), linewidth = 1) +
  ggplot2::geom_line(ggplot2::aes(y = Especificidade), linetype = 2, linewidth = 1) +
  ggplot2::geom_vline(xintercept = opt$threshold, linetype = 3) +
  ggplot2::annotate("point",
                    x = opt$threshold,
                    y = 0.5*(opt$Sensibilidade + opt$Especificidade),
                    size = 2
  ) +
  # üëâ r√≥tulo com t* (ajuste hjust/vjust conforme preferir)
  ggplot2::annotate("text",
                    x = opt$threshold,
                    y = 0.75,                 # posi√ß√£o vertical do texto
                    label = lbl,
                    hjust = -0.1, vjust = 1,  # empurra um pouco para a direita do t*
                    size = 3.5
  ) +
  ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0,1)) +
  ggplot2::labs(
    x = "Limiar de probabilidade (t)",
    y = "Propor√ß√£o de casos corretamente identificados",
    title = "Trade-off entre Sensibilidade e Especificidade",
    caption = "Linhas: s√≥lida = Sensibilidade; tracejada = Especificidade; pontilhada = Limiar √≥timo (Youden J)"
  ) +
  ggplot2::theme_minimal(base_size = 12)
```

<br>

-   Valor preditivo positivo ($VPP$) \@ref(eq:vpp): Propor√ß√£o de casos corretamente identificados como verdadeiro-positivos.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:vpp)
VPP = \dfrac{VP}{VP+FP}
\end{equation}

<br>

-   Valor preditivo negativo ($VPN$) \@ref(eq:vpn): Propor√ß√£o de controles corretamente identificados como verdadeiro-negativos.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:vpn)
VPN = \dfrac{VN}{VN+FN}
\end{equation}

<br>

- Raz√£o de verossimilhan√ßa positiva ($LR+$) \@ref(eq:lrplus): Quantifica o quanto a probabilidade de a condi√ß√£o estar presente aumenta quando o teste √© positivo.[@REF]

\begin{equation}
(\#eq:lrplus)
LR+ = \dfrac{SEN}{1 - ESP} = \dfrac{VP/(VP+FN)}{FP/(FP+VN)}
\end{equation}

<br>

- Raz√£o de verossimilhan√ßa negativa ($LR-$) \@ref(eq:lrminus): Quantifica o quanto a probabilidade de a condi√ß√£o estar presente diminui quando o teste √© negativo.[@REF]

\begin{equation}
(\#eq:lrminus)
LR- = \dfrac{1 - SEN}{ESP} = \dfrac{FN/(VP+FN)}{VN/(FP+VN)}
\end{equation}

<br>

-   Acur√°cia ($ACU$), \@ref(eq:acu): Propor√ß√£o de casos e controles corretamente identificados.[@greenhalgh1997b]

<br>

\begin{equation}
(\#eq:acu)
ACU = \dfrac{VP+VN}{VP+VN+FP+FN}
\end{equation}

<br>

-   Raz√£o de chances diagn√≥stica ($DOR$) \@ref(eq:dor1), \@ref(eq:dor2) e \@ref(eq:dor3): Raz√£o entre a chance de um teste ser positivo quando a condi√ß√£o est√° presente e a chance de um teste ser positivo quando a condi√ß√£o est√° ausente.[@Glas2003]

\begin{equation}
(\#eq:dor1)
DOR = \dfrac{VP}{FN} \div \dfrac{FP}{VN} = \dfrac{VP \cdot VN}{FP \cdot FN}
\end{equation}

<br>

\begin{equation}
(\#eq:dor2)
DOR = \dfrac{SEN/(1-SEN)}{(1-ESP)/ESP} = \dfrac{SEN \cdot ESP}{(1-SEN) \cdot (1-ESP)}
\end{equation}
<br>

\begin{equation}
(\#eq:dor3)
DOR = \dfrac{LR+}{LR-}
\end{equation}

<br>

```{r crosstable-prob, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
library(dplyr)

cross.table <-
  matrix(
    c(
      '$VP$',
      '$FN$',
      '$VP+FN$',
      '$SEN = \\frac{VP}{VP+FN}$',
      '$FP$',
      '$VN$',
      '$FP+VN$',
      '$ESP = \\frac{VN}{VN+FP}$',
      '$VP+FP$',
      '$FN+VN$',
      '$N=VP+VN+FP+FN$',
      '',
      '$VPP = \\frac{VP}{VP+FP}$',
      '$VPN = \\frac{VN}{VN+FN}$',
      '',
      '$ACU = \\frac{VP+VN}{VP+VN+FP+FN}$ \\ $DOR = \\frac{VP \\cdot VN}{FP \\cdot FN}$'
    ),
    nrow = 4,
    ncol = 4,
    byrow = FALSE
  )

rownames(cross.table) <- c("Teste positivo", "Teste negativo", "Total", "Probabilidades")
colnames(cross.table) <- c("Condi√ß√£o presente",
                           "Condi√ß√£o ausente",
                           "Total",
                           "Probabilidades")

# exibe a tabela de dados
kableExtra::kable(
  cross.table,
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  escape = FALSE,
  caption = "Probabilidades calculados a partir da tabela de confus√£o 2x2 para an√°lise de desempenho diagn√≥stico de testes e vari√°veis dicot√¥micas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec((dim(cross.table)[1] - 1), bold = TRUE, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::row_spec(dim(cross.table)[1], extra_css = "border-bottom: 1px solid")
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *riskyr*[@riskyr] fornece a fun√ß√£o [*comp_prob*](https://www.rdocumentation.org/packages/riskyr/versions/0.4.0/topics/comp_prob) para estimar 13 probabilidades relacionadas ao desempenho diagn√≥stico em tabelas 2x2.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *caret*[@caret] fornece a fun√ß√£o [*confusionMatrix*](https://www.rdocumentation.org/packages/caret/versions/3.45/topics/confusionMatrix) para estimar 11 probabilidades relacionadas ao desempenho diagn√≥stico em tabelas 2x2.
:::

<br>

## Tabelas 2x3

<br>

### O que √© uma tabela de confus√£o 2x3?

-   √â a extens√£o da tabela 2√ó2 que inclui uma terceira decis√£o (deferimento/*boundary*) al√©m de aceitar (positivo) e rejeitar (negativo).[@xu2020]

-   As colunas\*\* representam as decis√µes\*\* ($POS$, $BND$, $NEG$) e as linhas representam a verdade de refer√™ncia (condi√ß√£o presente vs ausente).[@xu2020]

-   Essa formula√ß√£o vem do arcabou√ßo de *Three-Way Decisions (3WD)*, que particiona o universo em tr√™s regi√µes por dois limiares $\alpha$ e $\beta$.[@xu2020]

<br>

### Como as regi√µes POS, BND e NEG s√£o definidas?

-   Dado um escore ou probabilidade condicional $Pr(C\mid[x])$ para a classe $C$, classifica-se como $POS$ (aceitar) quando $Pr(C\mid[x]) \ge \alpha$, como $BND$ (deferir) quando $\beta < Pr(C\mid[x]) < \alpha$ e como $NEG$ (rejeitar) quando $Pr(C\mid[x]) \le \beta$, sendo que os limiares $(\alpha,\beta)$ determinam simultaneamente as tr√™s regi√µes e os *trade-offs* entre acur√°cia e comprometimento.[@xu2020]

<br>

### Qual √© o formato de uma tabela 2√ó3?

-   Estrutura geral (linhas = condi√ß√£o real; colunas = decis√£o):

```{r crosstable-2x3, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
# matriz 2x3 (refer√™ncia vs decis√£o) ‚Äî c√©lulas simb√≥licas
cross3 <- matrix(
  c("$|POS\\cap C|$",   "$|BND\\cap C|$",   "$|NEG\\cap C|$",
    "$|POS\\cap C^c|$", "$|BND\\cap C^c|$", "$|NEG\\cap C^c|$"),
  nrow = 2, byrow = TRUE
)
rownames(cross3) <- c("Condi√ß√£o presente (C)", "Condi√ß√£o ausente ($C^c$)")
colnames(cross3) <- c("POS (aceitar)", "BND (deferir)", "NEG (rejeitar)")

# ---- adicionar totais (simb√≥licos) ----
# adiciona coluna "Total"
cross3_totais <- cbind(
  cross3,
  "Total" = c(
    "$|POS\\cap C|+|BND\\cap C|+|NEG\\cap C|$",
    "$|POS\\cap C^c|+|BND\\cap C^c|+|NEG\\cap C^c|$"
  )
)

# adiciona linha "Total"
linha_total <- matrix(
  c(
    "$|POS\\cap C|+|POS\\cap C^c|$",
    "$|BND\\cap C|+|BND\\cap C^c|$",
    "$|NEG\\cap C|+|NEG\\cap C^c|$",
    "$N$"
  ),
  nrow = 1
)
rownames(linha_total) <- "Total"
colnames(linha_total) <- colnames(cross3_totais)

cross3_totais <- rbind(cross3_totais, linha_total)

# ---- renderiza√ß√£o kable/kableExtra ----
kableExtra::kable(
  cross3_totais,
  align   = "c",
  format  = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  escape  = FALSE,
  caption = "Tabela de confus√£o 3-vias (2√ó3) com totais: refer√™ncia vs decis√£o (3WD)."
) |>
  kableExtra::kable_styling(
    latex_options     = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width        = ifelse(knitr::is_html_output(), TRUE, TRUE),
    position          = "center"
  ) |>
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") |>
  kableExtra::row_spec(nrow(cross3_totais)-1, bold = TRUE, extra_css = "border-bottom: 1px solid") |>  # pen√∫ltima linha (antes do total) com borda
  kableExtra::column_spec(1, bold = TRUE) |>
  kableExtra::row_spec(nrow(cross3_totais), extra_css = "border-bottom: 1px solid")
```

<br>

### Quais s√£o as medidas b√°sicas na 2√ó3?

-   Acur√°cia em POS ($M_{PT}$), equa√ß√£o \@ref(eq:mpt): Propor√ß√£o de positivos corretamente identificados na regi√£o POS.[@xu2020]

\begin{equation}
(\#eq:mpt)
M_{PT} = \dfrac{|POS \cap C|}{|POS|}
\end{equation}

-   Erro em POS ($M_{PF}$), equa√ß√£o \@ref(eq:mpf): Propor√ß√£o de negativos incorretamente classificados na regi√£o POS.[@xu2020]

\begin{equation}
(\#eq:mpf)
M_{PF} = \dfrac{|POS \cap C^{c}|}{|POS|}
\end{equation}

-   Acur√°cia em NEG ($M_{NF}$), equa√ß√£o \@ref(eq:mnf): Propor√ß√£o de negativos corretamente identificados na regi√£o NEG.[@xu2020]

\begin{equation}
(\#eq:mnf)
M_{NF} = \dfrac{|NEG \cap C^{c}|}{|NEG|}
\end{equation}

-   Erro em NEG ($M_{NT}$), equa√ß√£o \@ref(eq:mnt): Propor√ß√£o de positivos incorretamente classificados na regi√£o NEG.[@xu2020]

\begin{equation}
(\#eq:mnt)
M_{NT} = \dfrac{|NEG \cap C|}{|NEG|}
\end{equation}

-   Fra√ß√µes em BND ($M_{BT}$ e $M_{BF}$), equa√ß√µes \@ref(eq:mbt) e \@ref(eq:mbf): Propor√ß√£o de deferimentos verdadeiros e falsos.[@xu2020]

\begin{equation}
(\#eq:mbt)
M_{BT} = \dfrac{|BND \cap C|}{|BND|}
\end{equation}
\begin{equation}
(\#eq:mbf)
M_{BF} = \dfrac{|BND \cap C^{c}|}{|BND|}
\end{equation}

<br>

### Como escolher os limiares \(\alpha\) e \(\beta\)?

-   Os limiares \((\alpha,\beta)\) controlam o tamanho das regi√µes $POS$, $NEG$ e $BND$ e, portanto, os *trade-offs* entre ‚Äúacertar mais‚Äù (acur√°cia nas regi√µes) e ‚Äúdecidir mais‚Äù (comprometimento; menos deferimentos).[@xu2020]

<br>

### Quando preferir 3-vias em vez de 2√ó2?

-   Quando o custo de erro √© assim√©trico e/ou h√° incerteza relevante.[@xu2020]

-   O deferimento ($BND$) evita decis√µes precipitadas e permite avalia√ß√£o adicional, equilibrando acur√°cia e cobertura.[@xu2020]

-   √â particularmente √∫til em triagens diagn√≥sticas com etapas confirmat√≥rias.[@xu2020]

<br>

## Curvas ROC

<br>

### O que representa a curva ROC?

-   A rela√ß√£o entre sensibilidade ($SEN$) no eixo vertical e $1 - ESP$ no eixo horizontal.[@he2024]

-   Cada ponto na curva corresponde a um ponto de corte poss√≠vel do teste.[@he2024]

<br>

### Quais s√£o os tipos de curva ROC?

-   Curva emp√≠rica: conecta diretamente os pontos obtidos a partir dos diferentes pontos de corte observados.[@park2004]

-   Curva suavizada (param√©trica): assume uma distribui√ß√£o binormal e gera uma curva ajustada por m√°xima verossimilhan√ßa.[@park2004]

<br>

### Como definir o melhor ponto de corte?

-   O ponto de corte em uma curva ROC representa um balan√ßo entre sensibilidade e especificidade, ou seja, a taxa de verdadeiros positivos e a taxa de falsos positivos.[@he2024; @park2004]

-   O m√©todo de Youden (equa√ß√£o \@ref(eq:youden) maximiza a diferen√ßa entre a taxa de verdadeiros positivos e a taxa de falsos positivos. O ponto de corte ideal ser√° aquele com maior valor de $Y$.[@YOUDEN1950]

\begin{equation}
(\#eq:youden)
Y = SEN + ESP - 1
\end{equation}

-   O m√©todo da dist√¢ncia Euclidiana (\@ref(eq:euclidean) minimiza a dist√¢ncia entre um ponto da curva ROC e o ponto (0,1), que representa sensibilidade perfeita ($SEN = 100%$) e especificidade perfeita ($ESP = 100%$). O ponto de corte ideal ser√° aquele com menor valor de $D$.[@yarnold2014]

\begin{equation}
(\#eq:euclidean)
D = \sqrt{(1 - SEN)^2 + (1 - ESP)^2}
\end{equation}

<br>

### O que √© a √°rea sob a curva (AUROC)?

-   A √°rea sob a curva ROC (AUC ou AUROC) quantifica o poder de discrimina√ß√£o ou desempenho diagn√≥stico na classifica√ß√£o de uma vari√°vel dicot√¥mica.[@de2022]

-   A √°rea sob a curva ($AUC$) resume o desempenho global e representa a probabilidade de o teste classificar corretamente um caso positivo selecionado aleatoriamente em rela√ß√£o a um caso negativo selecionado aleatoriamente.[@he2024]

<br>

### Como calcular a AUC?

-   M√©todo n√£o param√©trico: soma das √°reas trapezoidais sob a curva emp√≠rica. Pode subestimar AUC quando os dados s√£o discretos.[@park2004]

-   M√©todo param√©trico (binormal): mais robusto para dados em escala ordinal (ex: categorias diagn√≥sticas), com vi√©s reduzido.[@park2004]

-   AUC deve sempre vir acompanhada de intervalo de confian√ßa (IC95%).[@park2004]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *proc*[@pROC] fornece a fun√ß√£o [*plot.roc*](https://www.rdocumentation.org/packages/pROC/versions/1.18.4/topics/plot.roc) para criar uma curva ROC.
:::

<br>

### Como interpretar a √°rea sob a curva (ROC)?

-   A √°rea sob a curva AUC varia no intervalo $[0.5; 1]$, com valores mais elevados indicando melhor discrimina√ß√£o ou desempenho do modelo de classifica√ß√£o.[@de2022]

-   As interpreta√ß√µes qualitativas (isto √©: pobre/fraca/baixa, moderada/razo√°vel/aceit√°vel, boa ou muito boa/alta/excelente) dos valores de √°rea sob a curva s√£o arbitr√°rios e n√£o devem ser considerados isoladamente.[@de2022]

-   Modelos de classifica√ß√£o com valores altos de √°rea sob a curva podem ser enganosos se os valores preditos por esses modelos n√£o estiverem adequadamente calibrados.[@de2022]

-   Diferen√ßas pequenas entre AUCs podem n√£o ser estatisticamente significativas.[@he2024]

-   A interpreta√ß√£o cl√≠nica pode ser equivocada se n√£o houver teste estat√≠stico adequado.[@he2024]

-   Se as curvas v√™m do mesmo conjunto de pacientes, aplique o teste de DeLong.[@he2024]

-   Se as curvas v√™m de amostras independentes, use m√©todos como Dorfman-Alf.[@he2024]

<br>

### Por que uma AUC menor que 0.5 est√° errada?

-   Porque indica desempenho pior que o acaso.[@he2024]

-   Geralmente decorre de sele√ß√£o incorreta da dire√ß√£o do teste ou da vari√°vel de estado.[@he2024]

-   Verifique se o software est√° configurado para maiores valores indicam presen√ßa do evento ou o inverso.[@he2024]

-   Ajuste a dire√ß√£o do teste para que $AUC ‚â• 0.5$.[@he2024]

<br>

```{r roc, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Curva ROC (Receiver Operating Characteristic) para um modelos de classifica√ß√£o com diferentes desempenhos diagn√≥sticos."}
# reproduz√≠vel
set.seed(123)

# AUC alvo -> d' (duas Normais com mesma vari√¢ncia: AUC = Phi(d'/sqrt(2)))
dprime_from_auc <- function(target_auc) sqrt(2) * stats::qnorm(target_auc)

simulate_scores <- function(n_pos = 1000, n_neg = 1000, target_auc = 0.75) {
  dprime <- dprime_from_auc(target_auc)
  scores_neg <- stats::rnorm(n_neg, mean = 0, sd = 1)
  scores_pos <- stats::rnorm(n_pos, mean = dprime, sd = 1)
  tibble::tibble(
    y = c(rep(0L, n_neg), rep(1L, n_pos)),
    score = c(scores_neg, scores_pos)
  )
}

threshold_metrics <- function(df, thr) {
  y <- df$y
  pred <- as.integer(df$score >= thr)
  TP <- sum(pred == 1 & y == 1)
  FP <- sum(pred == 1 & y == 0)
  TN <- sum(pred == 0 & y == 0)
  FN <- sum(pred == 0 & y == 1)

  sens <- ifelse((TP + FN) > 0, TP / (TP + FN), NA_real_)
  spec <- ifelse((TN + FP) > 0, TN / (TN + FP), NA_real_)
  ppv  <- ifelse((TP + FP) > 0, TP / (TP + FP), NA_real_)
  npv  <- ifelse((TN + FN) > 0, TN / (TN + FN), NA_real_)
  acc  <- (TP + TN) / (TP + TN + FP + FN)
  f1   <- ifelse((2*TP + FP + FN) > 0, 2*TP / (2*TP + FP + FN), NA_real_)

  tibble::tibble(
    threshold = thr,
    TP = TP, FP = FP, TN = TN, FN = FN,
    Sensitivity = sens, Specificity = spec,
    PPV = ppv, NPV = npv, Accuracy = acc, F1 = f1
  )
}

build_roc_summary <- function(df, label_auc) {
  # Primeiro tenta com direction=">"
  roc_obj <- pROC::roc(
    response  = factor(df$y, levels = c(0,1)),
    predictor = df$score,
    quiet     = TRUE,
    direction = ">"
  )
  # Se por qualquer motivo ficar < 0.5, recalcula invertendo
  if (as.numeric(pROC::auc(roc_obj)) < 0.5) {
    roc_obj <- pROC::roc(
      response  = factor(df$y, levels = c(0,1)),
      predictor = df$score,
      quiet     = TRUE,
      direction = "<"
    )
  }

  # Cutoffs
  youden <- pROC::coords(
    roc_obj, x = "best", best.method = "youden",
    ret = c("threshold","sensitivity","specificity"), transpose = FALSE
  )
  euclid <- pROC::coords(
    roc_obj, x = "best", best.method = "closest.topleft",
    ret = c("threshold","sensitivity","specificity"), transpose = FALSE
  )

  met_youden <- threshold_metrics(df, youden$threshold) |>
    dplyr::mutate(Cutoff = "Youden")
  met_euclid <- threshold_metrics(df, euclid$threshold) |>
    dplyr::mutate(Cutoff = "Euclidean")

  cut_table <- dplyr::bind_rows(
    tibble::tibble(Cutoff = "Youden",
      threshold = youden$threshold,
      Sensitivity = youden$sensitivity,
      Specificity = youden$specificity),
    tibble::tibble(Cutoff = "Euclidean",
      threshold = euclid$threshold,
      Sensitivity = euclid$sensitivity,
      Specificity = euclid$specificity)
  )

  list(
    auc_label   = label_auc,
    roc         = roc_obj,
    df          = df,
    coords_tbl  = cut_table,
    metrics_tbl = dplyr::bind_rows(met_youden, met_euclid)
  )
}

targets <- c(0.50, 0.75, 0.90)

data_list <- purrr::map(
  targets,
  ~{ d <- simulate_scores(n_pos = 1500, n_neg = 1500, target_auc = .x)
     build_roc_summary(d, label_auc = sprintf("AUC %.2f", .x)) }
)

cutoffs_tbl <- purrr::map_dfr(
  data_list,
  ~ .x$coords_tbl |>
    dplyr::mutate(Model = .x$auc_label) |>
    dplyr::relocate(Model, Cutoff)
)

metrics_tbl <- purrr::map_dfr(
  data_list,
  ~ .x$metrics_tbl |>
    dplyr::mutate(Model = .x$auc_label) |>
    dplyr::relocate(Model, Cutoff)
)

# --------- Curvas ROC (acima da diagonal) ----------
roc_df <- purrr::map_dfr(
  data_list,
  function(x) {
    gdat <- pROC::ggroc(x$roc)$data
    dplyr::mutate(gdat, Model = x$auc_label)
  }
)

cut_points <- cutoffs_tbl |>
  dplyr::mutate(FPR = 1 - Specificity,
                TPR = Sensitivity)

p <- ggplot2::ggplot() +
  ggplot2::geom_line(
    data = roc_df,
    ggplot2::aes(x = 1 - specificity, y = sensitivity, color = Model),
    linewidth = 1
  ) +
  ggplot2::geom_abline(
    intercept = 0, slope = 1,
    linewidth = 0.6, alpha = 0.6, linetype = "dashed"
  ) +
  ggplot2::geom_point(
    data = cut_points,
    ggplot2::aes(x = FPR, y = TPR, shape = Cutoff),
    size = 2.8
  ) +
  ggplot2::geom_hline(yintercept = 0, color = "black") +
  ggplot2::geom_vline(xintercept = 0, color = "black") +
  ggplot2::facet_wrap(~ Model) +
  ggplot2::labs(
    title = "Curva Caracter√≠stica de Opera√ß√£o do Receptor (Curva ROC)",
    x = "1 - Especificidade", y = "Sensibilidade",
    color = "Modelo", shape = "Cutoff"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::coord_equal(xlim = c(0,1), ylim = c(0,1)) +   # garante quadrado
  ggplot2::scale_x_continuous(limits = c(0,1), expand = c(0,0)) +
  ggplot2::scale_y_continuous(limits = c(0,1), expand = c(0,0))

print(p)
```

<br>

### Como analisar o desempenho diagn√≥stico em desfechos com distribui√ß√£o trimodal na popula√ß√£o?

-   Limiares duplos podem ser utilizados para an√°lise de desempenho diagn√≥stico de testes com distribui√ß√£o trimodal.[@ferreira2021]

<br>

## Gr√°ficos *crosshair*

<br>

### O que um gr√°fico *crosshair*?

-   .[@phillips2010]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *mada*[@mada] fornece a fun√ß√£o [*crosshair*](https://www.rdocumentation.org/packages/mada/versions/0.5.11/topics/crosshair) para criar um gr√°fico *crosshair*[@phillips2010] a partir de dados de verdadeiro-positivo, falso-positivo, verdadeiro-negativo e verdadeiro-positivo de tabelas de confus√£o 2x2.
:::

<br>

## Interpreta√ß√£o da validade de um teste

<br>

### Que itens devem ser verificados na interpreta√ß√£o de um estudo de validade?

-   O novo teste foi comparado junto ao m√©todo padr√£o-ouro.[@greenhalgh1997b]

-   As probabilidades pontuais estimadas que caracterizam o desempenho diagn√≥stico do novo teste s√£o altas e adequadas para sua aplica√ß√£o cl√≠nica.[@greenhalgh1997b]

-   Os intervalos de confian√ßa estimados para as probabilidades do novo teste s√£o estreitos e adequadas para sua aplica√ß√£o cl√≠nica.[@greenhalgh1997b]

-   O novo teste possui adequada confiabilidade intra/inter examinadores.[@greenhalgh1997b]

-   O estudo de valida√ß√£o incluiu um espectro adequado da amostra.[@greenhalgh1997b]

-   Todos os participantes realizaram ambos o novo teste e o padr√£o-ouro no estudo de valida√ß√£o.[@greenhalgh1997b]

-   Os examinadores do novo teste estavam cegados para o resultado do teste padr√£o-ouro.[@greenhalgh1997b]

<br>

## Diretrizes para reda√ß√£o

<br>

### Quais s√£o as diretrizes para reda√ß√£o de estudos diagn√≥sticos?

-   Visite a rede *Enhancing the QUAlity and Transparency Of health Research* ([EQUATOR Network](https://www.equator-network.org/)) para encontrar diretrizes espec√≠ficas.

-   *STARD 2015: An Updated List of Essential Items for Reporting Diagnostic Accuracy Studies*:[@bossuyt2015] <https://www.equator-network.org/reporting-guidelines/stard/>

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
