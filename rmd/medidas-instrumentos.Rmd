# **Medidas e instrumentos** {#medidas-instrumentos}

<br>

## Escalas

<br>

### O que são escalas?

-   Uma escala de medição grosseira representa um construto de natureza contínua medido por itens tais que diferentes pontuações são agrupadas na mesma categoria no ato da coleta de dados.[@aguinis2008]

-   Em escalas grosseiras, erros são introduzidos porque as variações contínunas do constructo são colapsadas em uma mesma categorias ou separadas entre categorias próximas.[@aguinis2008]

-   Escalas tipo Likert com 5 categorias tipo "discordo totalmente", "discordo parcialmente", "nem concordo nem discordo", "concordo parcialmente", e "concordo totalmente" são escalas grosseira porque as diferenças entre as categorias não são iguais. Por exemplo, a diferença entre "discordo totalmente" e "discordo parcialmente" não é a mesma que a diferença entre "concordo parcialmente" e "concordo totalmente".[@aguinis2008]

<br>

```{r, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Exemplo de instrumento com 3 itens tipo Likert com 5 categorias cada."}
# Reprodutibilidade
set.seed(1234)

# pacotes necessários
library(dplyr)

niveis <- c(
  "Discordo\ntotalmente",
  "Discordo\nparcialmente",
  "Nem concordo\nnem discordo",
  "Concordo\nparcialmente",
  "Concordo\ntotalmente"
)

# Simulação de dados tipo Likert
dados_prom <- base::data.frame(
  Item1 = base::factor(
    base::sample(
      c(
        "Discordo\ntotalmente",
        "Discordo\nparcialmente",
        "Nem concordo\nnem discordo",
        "Concordo\nparcialmente",
        "Concordo\ntotalmente"
      ),
      50,
      replace = TRUE
    ),
    levels = niveis
  ),
  Item2 = base::factor(
    base::sample(
      c(
        "Discordo\ntotalmente",
        "Discordo\nparcialmente",
        "Nem concordo\nnem discordo",
        "Concordo\nparcialmente",
        "Concordo\ntotalmente"
      ),
      50,
      replace = TRUE
    ),
    levels = niveis
  ),
  Item3 = base::factor(
    base::sample(
      c(
        "Discordo\ntotalmente",
        "Discordo\nparcialmente",
        "Nem concordo\nnem discordo",
        "Concordo\nparcialmente",
        "Concordo\ntotalmente"
      ),
      50,
      replace = TRUE
    ),
    levels = niveis
  )
)

# as factor
dados_prom <- dados_prom %>%
  dplyr::mutate(across(everything(), ~ factor(.x, levels = niveis)))

# Gráfico com rótulos solicitados
ggstats::gglikert(dados_prom, symmetric = TRUE)

# quebra de linha
cat("\n\n")

# Cria o objeto likert
likert_obj <- likert::likert(dados_prom)

# Converte o summary para data.frame
dados <- base::as.data.frame(summary(likert_obj))
# ordenar pela ordem alfabética da 1a coluna
dados <- dados[order(dados[, 1]), ]

# formata a visualzação de casas decimais das variáveis numéricas
dados[, 2:4] <- base::round(dados[, 2:4], digits = 0)
dados[, 5:6] <- base::round(dados[, 5:6], digits = 2)

# Ajuste de alinhamento: 1ª coluna à esquerda, demais centralizadas
alinhamento <- base::rep("c", base::ncol(dados))
alinhamento[1] <- "l"

# Ajuste de rótulos
names(dados) <- c(
  "Itens",
  "Discordância",
  "Neutro",
  "Concordância",
  "Média",
  "DP"
)

# Render da tabela
kableExtra::kable(
  dados,
  align = alinhamento,
  format = base::ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  escape = FALSE,
  caption = "Descrição dos itens tipo Likert do instrumento."
) %>%
  kableExtra::kable_styling(
    latex_options = c("basic"),
    bootstrap_options = c("basic", "hover", "condensed", "responsive"),
    full_width = base::ifelse(knitr::is_html_output(), TRUE, TRUE),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::row_spec(base::dim(dados)[1], extra_css = "border-bottom: 1px solid")
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *likert*[@likert] fornece a função [*likert*](https://www.rdocumentation.org/packages/likert/versions/1.3.5/topics/likert) para analisar respostas de instrumentos em escala tipo Likert.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *ggstats*[@ggstats] fornece a função [*gglikert*](https://www.rdocumentation.org/packages/ggstats/versions/0.10.0/topics/gglikert) para gerar um gráfico em escalas tipo Likert.
:::

<br>

-   O erros em escalas grosseiras é considerado sistemático mas não pode ser corrigido em nível da unidade de análise.[@aguinis2008]

<br>

## Medição e Medidas

<br>

### O que é medição?

-   Processo empírico, realizado por meio de um instrumento, que estabelece uma correspondência rigorosa e objetiva entre uma observação e uma categoria em um modelo da observação.[@ferris2004]

-   Esse processo tem como objetivo distinguir de maneira substantiva a manifestação observada de outras possíveis manifestações que também possam ser diferenciadas.[@ferris2004]

<br>

### O que são medidas diretas?

-   .[@REF]

<br>

### O que são medidas derivadas?

-   .[@REF]

<br>

### O que são medidas por teoria?

-   .[@REF]

<br>

### O que são medidas únicas?

```{r k1, include = FALSE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "hide"}
# sorteia participante para relatar no texto
set.seed(1)
k1 <- sample(1:10, 1)
```

```{r medidas-unicas, include = FALSE, echo = FALSE, results = "hide"}
# para reprodutibilidade das simulações
set.seed(1)

# tamanho do grupo
n <- 100

# cria o fator unidade de análise, sem reposição
ID <- seq(1:n)

# determina os limites do espaço amostral para sorteio
inferior <- 110
superior <- 120

# sorteia n dados no intervalo min-max, com reposição para cada variável
VAR.1 <- sample(inferior:superior, n, replace = TRUE)

# organiza as informações de unidade de análise e dados
table.1 <- data.frame(ID, VAR.1)

# atribui rótulos para a tabela de dados
colnames(table.1) <-
  c("Unidade de análise", "Pressão arterial, braço esquerdo (mmHg)")

# exibe as 10 linhas iniciais da tabela de dados
kableExtra::kable(
  head(table.1, n = 10L),
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  caption = "Dados brutos com medidas únicas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("striped"),
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec(10, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::row_spec(k1, background = "#E6E6E6", bold = TRUE)
```

-   A medida única da pressão arterial sistólica no braço esquerdo resulta em um valor pontual.[@REF]

-   Medidas únicas obtidas de diferentes unidades de análise podem ser consideradas independentes se observadas outras condições na coleta de dados.[@REF]

-   O valor pontual será considerado representativo da variável para a unidade de análise (ex.: **`r VAR.1[k1]` mmHg** para o participante **\#`r k1`**).

<br>

```{r medidas-unicas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
```

<br>

### O que são medidas repetidas?

```{r k2, include = FALSE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "hide"}
# sorteia participante para relatar no texto
set.seed(2)
k2 <- sample(1:10, 1)
```

```{r medidas-repetidas-separadas, include = FALSE, echo = FALSE, results = "hide"}
# para reprodutibilidade das simulações
set.seed(2)

# tamanho do grupo
n <- 100

# cria o fator unidade de análise, sem reposição
ID <- seq(1:n)

# determina os limites do espaço amostral para sorteio
inferior <- 110
superior <- 120

# sorteia n dados no intervalo min-max, com reposição para cada variável
VAR.1 <- sample(inferior:superior, n, replace = TRUE)
VAR.2 <- sample(inferior:superior, n, replace = TRUE)
VAR.3 <- sample(inferior:superior, n, replace = TRUE)

# organiza as informações de unidade de análise e dados
VAR <- data.frame(VAR.1, VAR.2, VAR.3)
table.2 <- data.frame(ID, VAR)

# atribui rótulos para a tabela de dados
colnames(table.2) <-
  c(
    "Unidade de análise",
    "Pressão arterial, braço esquerdo (mmHg) #1",
    "Pressão arterial, braço esquerdo (mmHg) #2",
    "Pressão arterial, braço esquerdo (mmHg) #3"
  )

# exibe as 10 linhas iniciais da tabela de dados
kableExtra::kable(
  head(table.2, n = 10L),
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  caption = "Dados brutos com medidas repetidas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("striped"),
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec(10, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::row_spec(k2, background = "#E6E6E6", bold = TRUE)
```

-   As medidas repetidas podem ser tabuladas separadamente, por exemplo para análise da confiabilidade de obtenção dessa medida.[@REF]

-   A medida repetida da pressão arterial no braço esquerdo resulta em um conjunto de valores pontuais (ex.: **`r VAR.1[k2]` mmHg**, **`r VAR.2[k2]` mmHg** e **`r VAR.3[k2]` mmHg** para o participante **\#`r k2`**).

<br>

```{r medidas-repetidas-separadas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
```

```{r medidas-repetidas-agregadas, include = FALSE, echo = FALSE, results = "hide"}
# para reprodutibilidade das simulações
set.seed(2)

# tamanho do grupo
n <- 100

# cria o fator unidade de análise, sem reposição
ID <- seq(1:n)

# determina os limites do espaço amostral para sorteio
inferior <- 110
superior <- 120

# sorteia n dados no intervalo min-max, com reposição para cada variável
VAR.1 <- sample(inferior:superior, n, replace = TRUE)
VAR.2 <- sample(inferior:superior, n, replace = TRUE)
VAR.3 <- sample(inferior:superior, n, replace = TRUE)

# organiza as informações de unidade de análise e dados
VAR <- data.frame(VAR.1, VAR.2, VAR.3)

# converte dados para variável numérica contínua
VAR <- sapply(VAR, as.numeric)

# agrega os valores repetidos em linhas com a média
VAR.aggr <- round(apply(VAR, 1, FUN = mean), 0)

# organiza as informações de unidade de análise e dados
table.3 <- data.frame(ID, VAR.aggr)

# formata a visualzação de casas decimais das variáveis numéricas
table.3 <- format(table.3, nsmall = 0)

# atribui rótulos para a tabela de dados
colnames(table.3) <-
  c("Unidade de análise",
    "Pressão arterial, braço esquerdo (mmHg) média")

# exibe as 10 linhas iniciais da tabela de dados
kableExtra::kable(
  head(table.3, n = 10L),
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  caption = "Dados brutos com medidas repetidas agregadas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("striped"),
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec(10, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::row_spec(k2, background = "#E6E6E6", bold = TRUE)
```

<br>

-   As medidas repetidas podem ser agregadas por algum parâmetro --- ex.: média, mediana, máximo, mínimo, entre outros ---, observando-se a relevância biológica, clínica e/ou metodológica desta escolha.[@REF]

-   Medidas agregadas obtidas de diferentes unidades de análise podem ser consideradas independentes se observadas outras condições na coleta de dados.[@REF]

-   O valor agregado será considerado representativo da variável para a unidade de análise (ex.: média = **`r round(VAR.aggr[k2], digits = 0)` mmHg** para o participante **\#`r k2`**).

<br>

```{r medidas-repetidas-agregadas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *stats*[@stats] fornece a função [*aggregate*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) para agregar medidas repetidas utilizando uma função personalizada.
:::

<br>

### O que são medidas seriadas?

```{r k3, include = FALSE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "hide"}
# sorteia participante para relatar no texto
set.seed(2)
k2 <- sample(1:10, 1)
```

```{r medidas-seriadas-separadas, include = FALSE, echo = FALSE, results = "hide"}
# para reprodutibilidade das simulações
set.seed(3)

# tamanho do grupo
n <- 100

# cria o fator unidade de análise, sem reposição
ID <- seq(1:n)

# número de medidas seriadas
k <- 3

# determina os limites do espaço amostral para sorteio
inferior <- 110
superior <- 120

# prepara a tabela de resultados
table.4 <-
  data.frame(matrix(
    vector(),
    nrow = 0,
    ncol = 3,
    dimnames = list(
      c(),
      c(
        "Unidade de análise",
        "Tempo (min)",
        "Pressão arterial, braço esquerdo (mmHg)"
      )
    )
  ))

# para cada série
for (i in 1:k) {
  # cria o fator de repetição seriada
  TIME <- rep(i, n)
  
  # sorteia n dados no intervalo min-max, com reposição para cada variável
  VAR <- sample(inferior:superior, n, replace = TRUE)
  
  # organiza as informações de unidade de análise e dados
  serie <- data.frame(ID, TIME, VAR)
  
  # atribui rótulos para a tabela de dados
  colnames(serie) <-
    c("Unidade de análise",
      "Tempo (min)",
      "Pressão arterial, braço esquerdo (mmHg)")
  
  # concatena as informações de unidade de análise e dados para cada série de coleta
  table.4 <- rbind(table.4, serie)
}

# reordena a tabela de dados
table.4 <-
  table.4[order(table.4[, 1], table.4[, 2], decreasing = FALSE), ]

# atribui rótulos para a tabela de dados
colnames(table.4) <-
  c("Unidade de análise",
    "Tempo (min)",
    "Pressão arterial, braço esquerdo (mmHg)")

# remove rótulos para as linhas
row.names(table.4) <- NULL

# exibe as 10 linhas iniciais da tabela de dados
kableExtra::kable(
  head(table.4, n = 10L),
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  caption = "Dados brutos com medidas seriadas não agregadas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("striped"),
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec(10, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::row_spec(1:3, background = "#E6E6E6", bold = TRUE)
```

-   Medidas seriadas são possivelmente relacionadas e, portanto, dependentes na mesma unidade de análise.[@REF]

-   Por exemplo, a medida seriada da pressão arterial no braço esquerdo, em intervalos tipicamente regulares (ex.: **`r table.4[1,3]` mmHg**, **`r table.4[2,3]` mmHg** e **`r table.4[3,3]` mmHg** em **`r 1` min**, **`r 2` min** e **`r 3` min**, respectivamente, para o participante **#1**).

<br>

```{r medidas-seriadas-separadas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
```

```{r medidas-seriadas-agregadas, include = FALSE, echo = FALSE, results = "hide"}
# para reprodutibilidade das simulações
set.seed(3)

# tamanho do grupo
n <- 100

# cria o fator unidade de análise, sem reposição
ID <- seq(1:n)

# número de medidas seriadas
k <- 3

# determina os limites do espaço amostral para sorteio
inferior <- 110
superior <- 120

# prepara a tabela de resultados
table.5 <-
  data.frame(matrix(
    vector(),
    nrow = 0,
    ncol = 3,
    dimnames = list(
      c(),
      c(
        "Unidade de análise",
        "Tempo (min)",
        "Pressão arterial, braço esquerdo (mmHg)"
      )
    )
  ))

# para cada série
for (i in 1:k) {
  # cria o fator de repetição seriada
  TIME <- rep(i, n)
  
  # sorteia n dados no intervalo min-max, com reposição para cada variável
  VAR <- sample(inferior:superior, n, replace = TRUE)
  
  # organiza as informações de unidade de análise e dados
  serie <- data.frame(ID, TIME, VAR)
  
  # atribui rótulos para a tabela de dados
  colnames(serie) <-
    c("Unidade de análise",
      "Tempo (min)",
      "Pressão arterial, braço esquerdo (mmHg)")
  
  # concatena as informações de unidade de análise e dados para cada série de coleta
  table.5 <- rbind(table.5, serie)
}

# converte dados para variável numérica contínua
table.5[, 3] <- sapply(table.5[, 3], as.numeric)

# agrega os valores seriados em linhas com a amplitude
table.5 <-
  aggregate(
    table.5[, 3] ~ table.5[, 1],
    FUN = function(x) {
      range(x)[2] - range(x)[1]
    }
  )

# formata a visualzação de casas decimais das variáveis numéricas
table.5 <- format(table.5, nsmall = 0)

# atribui rótulos para a tabela de dados
colnames(table.5) <-
  c("Unidade de análise",
    "Pressão arterial, braço esquerdo (mmHg) amplitude")

# exibe as 10 linhas iniciais da tabela de dados
kableExtra::kable(
  head(table.5, n = 10L),
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  caption = "Dados brutos com medidas seriadas não agregadas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("striped"),
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec(10, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::row_spec(1, background = "#E6E6E6", bold = TRUE)
```

<br>

-   Medidas seriadas também agregadas por parâmetros --- ex.: máximo, mínimo, amplitude --- são consideradas representativas da variação temporal ou de uma característica de interesse (ex.: amplitude = **`r table.5[1,2]` mmHg** para o participante **#1**).

<br>

```{r medidas-seriadas-agregadas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *stats*[@stats] fornece a função [*aggregate*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) para agregar medidas repetidas utilizando uma função personalizada.
:::

<br>

### O que são medidas múltiplas?

```{r k4, include = FALSE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "hide"}
# sorteia participante para relatar no texto
set.seed(4)
k4 <- sample(1:10, 1)
```

```{r medidas-multiplas, include = FALSE, echo = FALSE, results = "hide"}
# para reprodutibilidade das simulações
set.seed(4)

# tamanho do grupo
n <- 100

# cria o fator unidade de análise, sem reposição
ID <- seq(1:n)

# determina os limites do espaço amostral para sorteio
inferior <- 110
superior <- 120

# sorteia n dados no intervalo min-max, com reposição para cada variável
VAR.1 <- sample(inferior:superior, n, replace = TRUE)
VAR.2 <- sample(inferior:superior, n, replace = TRUE)

# organiza as informações de unidade de análise e dados
VAR <- data.frame(VAR.1, VAR.2)
table.6 <- data.frame(ID, VAR)

# atribui rótulos para a tabela de dados
colnames(table.6) <-
  c(
    "Unidade de análise",
    "Pressão arterial, braço esquerdo (mmHg)",
    "Pressão arterial, braço direito (mmHg)"
  )

# exibe as 10 linhas iniciais da tabela de dados
kableExtra::kable(
  head(table.6, n = 10L),
  align = "c",
  format = ifelse(knitr::is_html_output(), "html", "latex"),
  booktabs = TRUE,
  linesep = "",
  caption = "Dados brutos com medidas múltiplas."
) %>%
  kableExtra::kable_styling(
    latex_options = c("striped"),
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = ifelse(knitr::is_html_output(), T, T),
    position = "center"
  ) %>%
  kableExtra::row_spec(0, bold = TRUE, extra_css = "border-top: 1px solid; border-bottom: 1px solid") %>%
  kableExtra::row_spec(10, extra_css = "border-bottom: 1px solid") %>%
  kableExtra::row_spec(k4, background = "#E6E6E6", bold = TRUE)
```

-   Medidas múltiplas também são possivelmente relacionadas e, portanto, são dependentes na mesma unidade de análise. Medidas múltiplas podem ser obtidas de modo repetido para análise agregada ou seriada.[@REF]

-   A medida de pressão arterial bilateral resulta em um conjunto de valores pontuais (ex.: braço esquerdo = **`r round(VAR.1[k4], digits = 0)` mmHg**, braço direito = **`r round(VAR.2[k4], digits = 0)` mmHg** para o participante **\#`r k4`**). Neste caso, ambos os valores pontuais são considerados representativos daquela unidade de análise.

<br>

```{r medidas-multiplas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE}
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *stats*[@stats] fornece a função [*aggregate*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/aggregate) para agregar medidas repetidas utilizando uma função personalizada.
:::

<br>

## Erro de medida

<br>

### O que são erros de medida?

-   A natureza dos erros de medida são em geral atribuídos aos (1) instrumentos utilizados e variações no protocolo, na medida em que o seu tamanho médio pode ser reduzido por modificações e melhorias nesses instrumentos; e (2) variações genuínas medida em de curto prazo.[@healy1978]

- Estimativa pontual (um número exato) é um evento de probabilidade 0 sob um modelo contínuo.[@REF]

- Precisão como faixa $±\epsilon$ tem probabilidade > 0, mensurável e dependente de $\sigma$.[@REF]

- Isso motiva trabalhar com intervalos (faixas) em vez de pontos.[@REF]

<br>

```{r erro-medida, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Ilustração do conceito de erro de medida em um modelo simples com erro normal. A linha tracejada indica o valor verdadeiro (desconhecido na prática). A área sombreada representa a probabilidade de cair na faixa |X - θ| ≤ ε, que é > 0. A probabilidade de 'acertar no ponto' X = θ é 0 (linha tracejada)."}
# Erro de Medida: ponto tem P = 0, intervalos têm P > 0
# Modelo: X = θ + E, com E ~ Normal(0, σ^2)

# Reprodutibilidade
set.seed(123)

# Parâmetros do "mundo verdadeiro"
theta <- 10          # valor verdadeiro (desconhecido na prática)
sigma <- 2           # desvio-padrão do erro de medida
N     <- 1e6         # tamanho da simulação (grande para boa aproximação)

# Simulação de medidas com erro
X <- rnorm(N, mean = theta, sd = sigma)

# --- 2) Probabilidade de cair em uma faixa |X - θ| ≤ ε é > 0 ---
# Forma analítica (Normal): P(|X-θ| ≤ ε) = 2 * Φ(ε/σ) - 1
Phi <- pnorm
faixa_eps <- c(0.01, 0.05, 0.1, 0.25, 0.5, 1, 1.5, 2, 3)

prob_analitica <- 2 * Phi(faixa_eps / sigma) - 1
prob_empirica  <- sapply(faixa_eps, function(eps) mean(abs(X - theta) <= eps))

tabela <- data.frame(
  epsilon = faixa_eps,
  P_analitica = prob_analitica,
  P_empirica  = prob_empirica
)

# --- 3) Visualizações rápidas ---
# (a) Densidade com marca em θ (área em volta de θ corresponde à faixa)
df_plot <- data.frame(X = X[sample.int(N, size = 5e4)])  # subamostra para plot
g1 <- ggplot2::ggplot(df_plot, ggplot2::aes(x = X)) +
  ggplot2::geom_density() +
  ggplot2::geom_vline(xintercept = theta, linetype = "dashed") +
  ggplot2::labs(
    title = "Probabilidade de X = θ é 0",
    x = "Medida observada X", y = "Densidade"
  )

# (b) Densidade com faixa ±ε sombreada
eps_show <- 0.5  # escolha a precisão-alvo (faixa ±ε que você quer ilustrar)
a <- theta - eps_show
b <- theta + eps_show

# Densidade empírica para sombrear a área da faixa
dens <- density(X, n = 2048)
df_dens <- data.frame(x = dens$x, y = dens$y)

p_band <- 2 * pnorm(eps_show / sigma) - 1

g_mid <- ggplot2::ggplot(df_dens, ggplot2::aes(x = x, y = y)) +
  ggplot2::geom_line() +
  ggplot2::geom_area(
    data = subset(df_dens, x >= a & x <= b),
    ggplot2::aes(y = y),
    alpha = 0.3
  ) +
  ggplot2::geom_vline(xintercept = theta, linetype = "dashed") +
  ggplot2::geom_vline(xintercept = c(a, b), linetype = "dotted") +
  ggplot2::labs(
    title = "Faixa de Medida com Erro (±ε)",
    x = "Medida observada X", y = "Densidade"
  )

# (c) Curva P(|X-θ| ≤ ε) vs ε: analítica x empírica
df_eps <- data.frame(
  epsilon = rep(faixa_eps, 2),
  prob    = c(prob_analitica, prob_empirica),
  tipo    = rep(c("Analítica", "Empírica"), each = length(faixa_eps))
)

delta <- 0.02  # deslocamento opcional no eixo-x para separar visualmente

df_a <- subset(df_eps, tipo == "Analítica")
df_e <- subset(df_eps, tipo == "Empírica")

g2 <- ggplot2::ggplot() +
  # curva analítica como linha
  ggplot2::geom_line(
    data = df_a,
    mapping = ggplot2::aes(x = epsilon, y = prob, color = "Analítica"),
    linewidth = 1
  ) +
  # curva empírica como pontos (levemente deslocados em x)
  ggplot2::geom_point(
    data = transform(df_e, epsilon = epsilon + delta),
    mapping = ggplot2::aes(x = epsilon, y = prob, color = "Empírica"),
    size = 2
  ) +
  ggplot2::scale_color_discrete(name = NULL) +
  ggplot2::labs(
    title = "Probabilidade de cair na faixa |X - θ| ≤ ε",
    x = "ε (precisão)", y = "Probabilidade"
  ) +
  ggplot2::theme(legend.position = "bottom")

library(patchwork)
g1 + g_mid + g2
```

<br>

### Quais fontes de variabilidade são comumente investigadas?

-   Intra/Entre participantes (isto é, unidades de análise).[@altman1983]

-   Intra/Entre repetições.[@altman1983]

-   Intra/Entre observadores.[@altman1983]

<br>

## Instrumentos

<br>

### O que são instrumentos?

-   .[@REF]

<br>

## Acurácia e precisão

<br>

### O que é acurácia?

-   Acurácia expressa a proximidade de concordância entre uma mensuração e o valor real.[@menditto2006]

-   Acurária está para medidas como validade está para instrumentos de medida.[@REF]

<br>

### O que é precisão?

-   Precisão se refere à proximidade de concordância entre resultados de testes independentes obtidos nas mesmas condições de teste.[@menditto2006]

-   Precisão é um índice de quão próximo os resultados podem ser repetidos entre mensurações repetidas.[@Streiner2006]

-   Precisão está para medidas como confiabilidade está para instrumentos de medida.[@REF]

<br>

```{r acuracia-precisao, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.cap = "Acurácia e precisão como propriedades de uma medida."}
# função para criar o alvo
make_target_plot <- function(title, m_shift = 0, sd_spread = 0.1) {
  tibble::tibble(
    x = runif(10, min = m_shift - sd_spread, max = m_shift + sd_spread),
    y = runif(10, min = m_shift - sd_spread, max = m_shift + sd_spread)
  ) %>%
    ggplot2::ggplot(ggplot2::aes(x = x, y = y)) +
    # círculos concêntricos maiores
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 40, fill = "gray80", color = "black") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 36, fill = "white", color = "white") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 32, fill = "gray70", color = "gray70") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 28, fill = "white", color = "white") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 24, fill = "gray60", color = "gray60") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 20, fill = "white", color = "white") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 16,  fill = "gray50", color = "gray50") +
    ggplot2::geom_point(ggplot2::aes(x = 0, y = 0), shape = 21, size = 12,  fill = "white", color = "white") +
    # pontos aleatórios
    ggplot2::geom_point(shape = 4, size = 4, stroke = 1.2, color = "black") +
    ggplot2::coord_fixed(xlim = c(-1.0, 1.0), ylim = c(-1.0, 1.0)) +
    ggplot2::theme_void() +
    ggplot2::ggtitle(title)
}

# reprodutibilidade
set.seed(1234)

# quatro plots
p1 <- make_target_plot("Acurácia alta, Precisão alta", m_shift = 0,   sd_spread = 0.1)
p2 <- make_target_plot("Acurácia baixa, Precisão alta", m_shift = 0.3, sd_spread = 0.1)
p3 <- make_target_plot("Acurácia alta, Precisão baixa", m_shift = 0,   sd_spread = 0.3)
p4 <- make_target_plot("Acurácia baixa, Precisão baixa", m_shift = 0.3, sd_spread = 0.3)

# grid 2x2
gridExtra::grid.arrange(p1, p2, p3, p4, ncol = 2)
```

<br>

## Viés e variabilidade

<br>

### Qual é a relação entre viés e variabilidade?

-   .[@REF]

<br>

```{r vies-variabilidade, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.cap = "Viés e variabilidade de uma medida."}
# para reprodutibilidade
set.seed(1234)

# Função para criar o alvo com os pontos
target_board_ggplot <- function(title,
                                m_shift = 0,
                                sd_spread = 0.1) {
  # Cria um dataframe com os pontos aleatórios
  df_points <- tibble::tibble(
    x = runif(10, min = m_shift - sd_spread, max = m_shift + sd_spread),
    y = runif(10, min = m_shift - sd_spread, max = m_shift + sd_spread)
  )
  
  ggplot2::ggplot(df_points, ggplot2::aes(x = x, y = y)) +
    # Círculos concêntricos do alvo
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 40,
      fill = "gray80",
      color = "black"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 36,
      fill = "white",
      color = "white"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 32,
      fill = "gray70",
      color = "gray70"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 28,
      fill = "white",
      color = "white"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 24,
      fill = "gray60",
      color = "gray60"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 20,
      fill = "white",
      color = "white"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 16,
      fill = "gray50",
      color = "gray50"
    ) +
    ggplot2::geom_point(
      ggplot2::aes(x = 0, y = 0),
      shape = 21,
      size = 12,
      fill = "white",
      color = "white"
    ) +
    
    # Adiciona os pontos aleatórios
    ggplot2::geom_point(
      shape = 4,
      size = 4,
      stroke = 1.2,
      color = "black"
    ) +
    
    # Define as coordenadas e o tema
    ggplot2::coord_fixed(xlim = c(-1.0, 1.0), ylim = c(-1.0, 1.0)) +
    ggplot2::theme_void() +
    ggplot2::ggtitle(title) +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
}

p1 <- target_board_ggplot("Viés alto, Variância baixa",
                          m_shift = 0.3,
                          sd_spread = 0.1)
p2 <- target_board_ggplot("Viés baixo, Variância alta",
                          m_shift = 0,
                          sd_spread = 0.2)
p3 <- target_board_ggplot("Viés baixo, Variância baixa",
                          m_shift = 0,
                          sd_spread = 0.1)

# Grid de 1x3 para exibir os plots
gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
```

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
