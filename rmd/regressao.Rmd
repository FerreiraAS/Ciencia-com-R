# **Regressão** {#regressao}

<br>

## Análise de regressão

<br>

### O que é regressão?

-   Regressão refere-se a uma equação matemática que permite que uma ou mais variável(is) de desfecho (dependentes) seja(m) prevista(s) a partir de uma ou mais variável(is) independente(s). A regressão implica em uma direção de efeito, mas não garante causalidade.[@greenhalgh1997a]

-   Para estimar os efeitos imparciais de um fator de exposição primária sobre uma variável de desfecho, frequentemente constroem-se modelos estatísticos de regressão.[@bandoli2018]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *modelsummary*[@modelsummary] fornece as funções [*modelsummary*](https://www.rdocumentation.org/packages/modelsummary/versions/1.4.1/topics/modelsummary) e [*modelplot*](https://www.rdocumentation.org/packages/modelsummary/versions/1.4.1/topics/modelplot) para gerar tabelas e gráficos de coeficientes de regressão.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *gtsummary*[@gtsummary] fornece a função [*tbl_regression*](https://www.rdocumentation.org/packages/gtsummary/versions/1.6.3/topics/tbl_regression) para construção da 'Tabela 2' com dados do modelo de regressão.
:::

<br>

### Quais são os algoritmos de regressão?

-   Linear: Simples, Múltipla, Polinomial.[@REF]

-   Linear generalizado: Binomial (logística), Multinomial, Ordinal, Poisson, Binomial negativa, Gama.[@REF]

-   Não-linear (nos parâmetros).[@REF]

-   Aditivo generalizado.[@REF]

-   Efeitos mistos: Linear, Generalizado.[@REF]

-   Sobrevida: Cox, Weibull, Exponencial, Log-normal, Log-logístico.[@REF]

-   Regularização: Ridge, LASSO[@REF]

<br>

## Estruturas de análise de regressão

<br>

### O que são análises de regressão simples?

-   A análise de regressão simples consiste em modelos estatísticos com uma variável dependente (desfecho) e uma variável independente (preditor).[@Hidalgo2013]

-   A equação de regressão simples é expressa como \@ref(eq:regressao-simples), onde $Y$ é a variável dependente, $X$ é a variável independente, $\beta_0$ é o intercepto (constante), $\beta_1$ é o coeficiente de regressão da variável independente e $\epsilon$ representa o erro aleatório do modelo.[@Hidalgo2013]

<br>

\begin{equation}
(\#eq:regressao-simples)
Y = \beta_0 + \beta_1 X + \epsilon
\end{equation}

<br>

### O que são análises de regressão multivariável?

-   A análise multivariável (ou múltiplo) consiste em modelos estatísticos com uma variável dependente (desfecho) e duas ou mais variáveis independentes.[@Hidalgo2013]

-   A equação de regressão multivariável é expressa como \@ref(eq:regressao-multivariavel), onde $Y$ é a variável dependente, $X_1, X_2, ..., X_n$ são as variáveis independentes, $\beta_0$ é o intercepto (constante), $\beta_1, \beta_2, ..., \beta_n$ são os coeficientes de regressão das variáveis independentes e $\epsilon$ representa o erro aleatório do modelo.[@Hidalgo2013]

<br>

\begin{equation}
(\#eq:regressao-multivariavel)
Y = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + ... + \beta_n X_n + \epsilon
\end{equation}

<br>

### O que são análises de regressão multivariada?

-   A análise multivariada consiste em modelos estatísticos com duas ou mais variáveis dependente (desfechos) e duas ou mais variáveis independentes.[@Hidalgo2013]

-   A equação de regressão multivariada é expressa como \@ref(eq:regressao-multivariada), onde $Y_1, Y_2, ..., Y_m$ são as variáveis dependentes, $X_1, X_2, ..., X_n$ são as variáveis independentes, $\beta_{0j}$ é o intercepto (constante) da variável dependente $Y_j$, $\beta_{ij}$ são os coeficientes de regressão das variáveis independentes para a variável dependente $Y_j$ e $\epsilon_j$ representa o erro aleatório do modelo para a variável dependente $Y_j$.[@Hidalgo2013]

<br>

\begin{align}
(\#eq:regressao-multivariada)
Y_1 &= \beta_{01} + \beta_{11} X_1 + \beta_{12} X_2 + \dots + \beta_{1n} X_n + \epsilon_1 \\
Y_2 &= \beta_{02} + \beta_{21} X_1 + \beta_{22} X_2 + \dots + \beta_{2n} X_n + \epsilon_2 \\
&\vdots \\
Y_m &= \beta_{0m} + \beta_{m1} X_1 + \beta_{m2} X_2 + \dots + \beta_{mn} X_n + \epsilon_m
\end{align}

<br>

## Tipos e famílias de regressão

<br>

### O que são modelos de regressão linear?

-   Modelos lineares \@ref(eq:regressao-linear) descrevem uma relação linear nos parâmetros entre um desfecho contínuo $Y$ e um ou mais preditores $X$.[@REF]

\begin{equation}
(\#eq:regressao-linear)
Y = \beta_0 + \sum_{i=1}^{n} \beta_i X_i + \epsilon
\end{equation}

-   Assumem erros independentes, de média zero e variância constante (homocedasticidade).[@REF]

-   A normalidade dos resíduos é uma hipótese comum para inferência estatística, mas não obrigatória para estimação dos coeficientes.[@REF]

<br>

```{r regressao-linear, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão linear."}
# simulate X
set.seed(123)
X <- rnorm(100, mean = 50, sd = 10)

# simulate Y based on X
Y <- 5 + 2 * X + rnorm(100, mean = 0, sd = 30)

# create a dataframe
data <- data.frame(X, Y)

# create the regression model
model <- lm(Y ~ X, data = data)

ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm",
                       color = "blue",   # cor da linha
                       fill = "grey70",  # cor da área IC95%
                       se = TRUE) +      # mostra o intervalo de confiança
  ggplot2::labs(title = "Regressão linear", 
                x = "Variável Independente (X)", 
                y = "Variável Dependente (Y)") +
  ggplot2::theme_minimal()
```

<br>

### O que são modelos de regressão polinomial?

-   São extensões da regressão linear em que se incluem termos elevados a potências das variáveis independentes (ex.: $X^2$, $X^3$), permitindo capturar relações curvas.[@REF]

-   Modelos de regressão polinomial continuam sendo lineares nos parâmetros, por isso ainda se enquadram como um caso particular da regressão linear.[@REF]

<br>

```{r regressao-polinomial, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão polinomial."}
# simulate X
set.seed(123)
X <- seq(-10, 10, length.out = 100)

# simulate Y based on a polynomial function of X
Y <- 5 + 2 * X^3 - 0.1 * X^2 + rnorm(100, mean = 0, sd = 30)

# create a dataframe
data <- data.frame(X, Y)

# create the regression model
model <- lm(Y ~ poly(X, 3), data = data)

ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm",
                       formula = y ~ poly(x, 3),
                       color = "blue",      # cor da linha
                       fill = "grey70",     # cor da faixa IC95%
                       se = TRUE) +         # ativa o intervalo de confiança
  ggplot2::labs(title = "Regressão polinomial",
                x = "Variável Independente (X)",
                y = "Variável Dependente (Y)") +
  ggplot2::theme_minimal()
```

<br>

### O que são modelos de regressão não-linear?

-   São modelos em que a relação entre os parâmetros e a variável resposta não é linear.

-   Podem assumir formas funcionais mais complexas (ex.: exponencial, logarítmica, logística).[@REF]

-   Importante diferenciar "não-linear na variável" (ex.: polinomial) de "não-linear no parâmetro" (ex.: modelos logísticos de crescimento).[@REF]

<br>

```{r regressao-nao-linear, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão não-linear."}
# simulate X
set.seed(123)
X <- seq(-10, 10, length.out = 100)

# simulate Y based on a non-linear function of X
Y <- 5 + 2 * X^2 + rnorm(100, mean = 0, sd = 30)

# create a dataframe
data <- data.frame(X, Y)

# create the regression model
model <- lm(Y ~ poly(X, 2), data = data)

# plot the regression line
ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "lm",
                       formula = y ~ poly(x, 2),
                       color = "blue",
                       fill = "grey70", # cor da área do IC
                       se = TRUE) +     # ativa o intervalo de confiança
  ggplot2::labs(title = "Regressão não-linear", 
                x = "Variável Independente (X)", 
                y = "Variável Dependente (Y)") +
  ggplot2::theme_minimal()
```

<br>

### O que são modelos de regressão logística?

-   Modelos logísticos são casos de regressão linear generalizada em que a resposta $Y$ é binária.[@REF]

-   A equação \@ref(eq:regressao-logistica) modela a razão de chances (*odds*) em função dos preditores.[@REF]

\begin{equation}
(\#eq:regressao-logistica)
\log\left(\frac{p}{1-p}\right) = \beta_0 + \beta_1 X + ... + \beta_n X_n
\end{equation}

<br>

-   A ligação (*link*) usada é o logit \@ref(eq:link-logit).[@REF]

\begin{equation}
(\#eq:link-logit)
g(p) = \log\left(\frac{p}{1-p}\right)
\end{equation}

<br>

```{r regressao-logistica, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão logística."}
# simulate X
set.seed(123)
X <- rnorm(100, mean = 50, sd = 10)

# simulate a binary outcome Y based on X
prob <- 1 / (1 + exp(-( -5 + 0.1 * X)))  # logistic function
Y <- rbinom(100, size = 1, prob = prob) # sample Y ~ Bernoulli(prob)

# create a dataframe
data <- data.frame(X, Y)

# create the logistic regression model
model <- glm(Y ~ X, data = data, family = binomial)

# plot the regression line
ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y)) +
  ggplot2::geom_point() +
  ggplot2::geom_smooth(method = "glm", method.args = list(family = "binomial"), color = "blue") +
  ggplot2::labs(title = "Regressão logística",
       x = "Variável Independente (X)",
       y = "Probabilidade de Sucesso (Y)") +
  ggplot2::theme_minimal()
```

<br>

### O que são modelos de regressão multinomial?

-   Modelos de regressão multinomial são usados quando a variável resposta é categórica com mais de dois níveis não ordenados.[@REF]

-   Estendem a regressão logística binária, modelando as razões de chances (*odds ratios*) de cada categoria em relação a uma categoria de referência.[@REF]

<br>

```{r regressao-multinomial, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão multinomial"}
library(tidyr)

# Reprodutibilidade
set.seed(123)

# 1) Simular X e Y (categorias A/B/C) via softmax
n <- 200
X <- rnorm(n, mean = 50, sd = 10)

# Defina preditores lineares por categoria (um "modelo verdadeiro" para simulação)
# A será a categoria de referência implícita no cálculo de probabilidades
eta_A <- 0
eta_B <- -2 + 0.05*X   # prob de B cresce com X
eta_C <-  2 - 0.08*X   # prob de C decresce com X

# Softmax para probabilidades
expA <- exp(eta_A)
expB <- exp(eta_B)
expC <- exp(eta_C)
den  <- expA + expB + expC
pA <- expA / den
pB <- expB / den
pC <- expC / den

# Amostrar categoria observada
Y_cat <- sapply(seq_len(n), function(i) {
  sample(c("A","B","C"), size = 1, prob = c(pA[i], pB[i], pC[i]))
})
Y_cat <- factor(Y_cat, levels = c("A","B","C"))

# Data frame
data <- data.frame(X = X, Y = Y_cat)

# 2) Ajustar regressão multinomial
# Por padrão, nnet::multinom usa a 1ª categoria (A) como referência
model <- nnet::multinom(Y ~ X, data = data, trace = FALSE)

# 3) Prever probabilidades ao longo de X para plotar as curvas
grid <- data.frame(X = seq(min(data$X), max(data$X), length.out = 200))
pred_probs <- predict(model, newdata = grid, type = "probs") %>% as.data.frame()
colnames(pred_probs) <- levels(data$Y)  # garantir nomes A, B, C
pred_long <- dplyr::bind_cols(grid, pred_probs) |>
  tidyr::pivot_longer(cols = c("A","B","C"),
               names_to = "categoria", values_to = "prob")

# 4) Gráficos

# (A) Dispersão: X vs Categoria observada (jitter no eixo Y)
p_obs <- ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y, color = Y)) +
  ggplot2::geom_jitter(height = 0.08, width = 0, alpha = 0.7, size = 2) +
  ggplot2::labs(title = "Observações",
       x = "Variável Independente (X)",
       y = "Categoria observada") +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "none")

# (B) Curvas de probabilidade prevista por X
p_prob <- ggplot2::ggplot(pred_long, ggplot2::aes(x = X, y = prob, color = categoria)) +
  ggplot2::geom_line(linewidth = 1.2) +
  ggplot2::labs(title = "Regressão Multinomial: Probabilidades preditas",
       x = "Variável Independente (X)",
       y = "Probabilidade") +
  ggplot2::theme_minimal() +
  ggplot2::scale_y_continuous(labels = scales::percent_format(accuracy = 1))

print(p_prob)
```

<br>

### O que são modelos de regressão ordinal?

-   Modelos de regressão ordinal são usados quando a variável resposta é categórica com mais de dois níveis ordenados.[@REF]

-   Modelam a probabilidade acumulada de estar em ou abaixo de cada categoria, usando uma função de ligação logit, probit ou log-log.[@REF]

-   Assumem a proporcionalidade dos coeficientes entre as categorias (*proportional odds*).[@REF]

<br>

### O que são modelos de regressão de Poisson?

-   Modelos de regressão de Poisson são usados quando a variável resposta é uma contagem de eventos não negativos.[@REF]

-   Assumem que $Y \sim Poisson(\mu)$, com $\mu = E[Y|X]$ relacionado aos preditores via função de ligação log.[@REF]

-   A sobre-dispersão (variância maior que a média) pode exigir modelos alternativos como a regressão binomial negativa.[@REF]

<br>

```{r regressao-poisson, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão de Poisson."}
# Reprodutibilidade
set.seed(123)

# Simulação de dados
X <- rnorm(100, mean = 50, sd = 10)
beta0 <- -2.5
beta1 <- 0.05
mu <- exp(beta0 + beta1 * X)
Y <- rpois(100, lambda = mu)

data <- data.frame(X = X, Y = Y)
mod_pois <- glm(Y ~ X, data = data, family = poisson(link = "log"))

# Diagnóstico rápido de sobredispersão
phi <- sum(residuals(mod_pois, type = "pearson")^2) / mod_pois$df.residual

# Predições no grid
x_grid <- seq(min(data$X), max(data$X), length.out = 200)
pred <- predict(mod_pois,
                newdata = data.frame(X = x_grid),
                type = "link", se.fit = TRUE)

link_fit <- pred$fit
link_se  <- pred$se.fit
link_lwr <- link_fit - 1.96 * link_se
link_upr <- link_fit + 1.96 * link_se

mu_hat <- exp(link_fit)
mu_lwr <- exp(link_lwr)
mu_upr <- exp(link_upr)

plot_df <- data.frame(
  X = x_grid,
  mu_hat = mu_hat,
  mu_lwr = mu_lwr,
  mu_upr = mu_upr
)

# Plot
ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y)) +
  ggplot2::geom_jitter(width = 0, height = 0.1, alpha = 0.6) +
  ggplot2::geom_ribbon(
    data = plot_df,
    aes(x = X, ymin = mu_lwr, ymax = mu_upr),
    inherit.aes = FALSE,
    alpha = 0.2
  ) +
  ggplot2::geom_line(
    data = plot_df,
    aes(x = X, y = mu_hat),
    linewidth = 1
  ) +
  ggplot2::labs(
    title = "Regressão de Poisson (link log)",
    x = "Variável Independente (X)",
    y = "Contagem esperada (E[Y|X])"
  ) +
  ggplot2::theme_minimal()
```

<br>

### O que são modelos de regressão binomial negativa?

-   Modelos de regressão binomial negativa são usados para contagens superdispersas, onde a variância excede a média.[@REF]

-   Introduzem um parâmetro de dispersão adicional para modelar a variabilidade extra.[@REF]

-   A função de ligação log é comumente usada, semelhante à regressão de Poisson.[@REF]

<br>

### O que são modelos de regressão Gama?

-   Modelos de regressão Gama são usados para variáveis resposta contínuas e positivas, frequentemente com distribuição assimétrica.[@REF]

-   A função de ligação log é comumente usada para garantir predições positivas.[@REF]

<br>

### O que são modelos de regressão com efeitos mistos?

-   Modelos de efeitos mistos incorporam efeitos fixos (coeficientes comuns a todos os indivíduos) e efeitos aleatórios (variações específicas de grupos ou indivíduos).[@REF]

-   Usados para dados hierárquicos ou longitudinais, onde observações estão agrupadas.[@REF]

-   Permitem modelar correlações intra-grupo e variabilidade entre grupos.[@REF]

<br>

### O que são modelos de regressão com efeitos mistos generalizados?

-   Modelos de efeitos mistos generalizados (GLMM) estendem os modelos de efeitos mistos para variáveis resposta que seguem distribuições da família exponencial (ex.: binomial, Poisson).[@REF]

-   Combinam a flexibilidade dos modelos lineares generalizados com a capacidade de modelar correlações e variabilidade entre grupos.[@REF]

-   Usados para dados hierárquicos ou longitudinais com desfechos não normais.[@REF]

<br>

### O que são modelos de regressão ridge?

-   Regressão ridge é um modelo linear regularizado que adiciona uma penalização L2 à soma dos quadrados dos coeficientes.[@REF]

-   Ajuda a reduzir multicolinearidade e overfitting, encolhendo os coeficientes em direção a zero, mas nunca os tornando exatamente nulos.[@REF]

-   O hiperparâmetro de regularização é $\lambda$, controlando a intensidade da penalização. Valores maiores de $\lambda$ resultam em maior encolhimento dos coeficientes.[@REF]

<br>

```{r regressao-ridge, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão ridge."}
# simulate X
set.seed(123)
X <- seq(-10, 10, length.out = 100)
Y <- 5 + 2 * X + rnorm(100, mean = 0, sd = 5)
data <- data.frame(X, Y)

# criar matriz de preditores com intercepto
X_matrix <- model.matrix(~ X, data = data)

# ajustar modelo de regressão ridge
model <- glmnet::glmnet(X_matrix, data$Y, alpha = 0)

# predições (usando lambda padrão)
predicted_Y <- predict(model, newx = X_matrix, s = 0.01)

# adicionar ao dataframe
data$Y_pred <- as.numeric(predicted_Y)

# plotar com ggplot
ggplot2::ggplot(data, ggplot2::aes(x = X, y = Y)) +
  ggplot2::geom_point(color = "gray40") +
  ggplot2::geom_line(ggplot2::aes(y = Y_pred), color = "blue", size = 1) +
  ggplot2::labs(title = "Regressão Ridge",
       x = "Variável Independente (X)",
       y = "Variável Dependente (Y)") +
  ggplot2::theme_minimal()
```

<br>

### O que são modelos de regressão LASSO?

-   Regressão LASSO (*Least Absolute Shrinkage and Selection Operator*) utiliza penalização L1, que pode zerar coeficientes.[@REF]

-   Além de reduzir *overfitting*, também realiza seleção automática de variáveis.[@REF]

-   Enquanto a regressão ridge mantém todos os preditores, a LASSO pode excluir variáveis irrelevantes.[@REF]

<br>

## Preparação de variáveis

<br>

### Como preparar as variáveis categóricas para análise de regressão?

-   Variáveis fictícias (*dummy*) compreendem variáveis criadas para introduzir, nos modelos de regressão, informações contidas em outras variáveis que não podem ser medidas em escala numérica.[@suits1957]

-   Variáveis categóricas nominais, com 2 ou mais níveis, devem ser subdivididas em variáveis fictícias dicotômicas para ser usada em modelos de regressão.[@Healy1995]

-   Cada nível da variável categórica nominal será convertido em uma nova variável fictícias dicotômica, tal que a nova variável dicotômica assume valor 1 para a presença do nível correspondente e 0 em qualquer outro caso.[@Healy1995]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *fastDummies*[@fastDummies] fornece a função [*dummy_cols*](https://www.rdocumentation.org/packages/fastDummies/versions/1.7.3/topics/dummy_columns) para preparar as variáveis categóricas fictícias para análise de regressão.
:::

<br>

### Por que é comum escolher a categoria mais frequente como referência em modelos epidemiológicos?

-   Maior estabilidade estatística: a categoria mais frequente costuma gerar estimativas mais estáveis, com menor erro padrão nos coeficientes das demais categorias.[@REF]

-   A escolha da referência não altera o ajuste nem o valor predito pelo modelo — apenas muda o ponto de comparação.[@REF]

<br>

## Multicolinearidade

<br>

### O que é multicolinearidade?

-   Multicolinearidade representa a intercorrelação entre as variáveis independentes (explanatórias) de um modelo.[@Kim2019]

<br>

### Como diagnosticar multicolinearidade de forma quantitativa?

-   Verifique a existência de multicolinearidade entre as variáveis candidatas.[@Sun1996]

-   O Coeficiente de determinação ($R^2$) é uma medida de quão bem as variáveis independentes explicam a variabilidade da variável dependente. Valores próximos a 1 indicam que as variáveis independentes estão fortemente correlacionadas entre si, o que pode indicar multicolinearidade.[@Kim2019]

-   O Fator de Inflação da Variância (*variance inflation factor*, VIF) é uma medida que quantifica o quanto a variância de um coeficiente de regressão é inflacionada devido à multicolinearidade. Valores de VIF maiores que 10 são frequentemente considerados indicativos de multicolinearidade significativa.[@Kim2019]

-   O recíproco da VIF é chamado de Tolerância, que mede a proporção da variância de uma variável independente que não é explicada pelas outras variáveis independentes. Valores baixos de Tolerância (geralmente abaixo de 0.1) indicam multicolinearidade.[@Kim2019]

-   O número de condições (*Condition Number*) é uma medida que avalia a estabilidade numérica de um modelo de regressão. Valores altos (entre 10 de 30) indicam multicolinearidade, e valores maiores que 30 indicam forte multicolinearidade.[@Kim2019]

<br>

```{r multicolinearidade, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Multicolinearidade entre variáveis candidatas em modelos de regressão multivariável."}
# Set the seed for reproducibility
set.seed(123)

# Generate an independent variable
X1 <- rnorm(100, mean = 50, sd = 10)

# Generate a second variable that is highly correlated with X1
X2 <- 0.8 * X1 + rnorm(100, mean = 0, sd = 5)

# Generate a third variable that is not correlated with X1 or X2
X3 <- rnorm(100, mean = 30, sd = 5)

# Combine the variables into a dataframe
data <- data.frame(X1, X2, X3)

# Create the customized grid plot
GGally::ggpairs(
  data, 
  lower = list(continuous = GGally::wrap("smooth", method = "lm")),
  diag = list(continuous = "densityDiag"),
  upper = list(continuous = "cor")
) +
  ggplot2::theme(
    panel.background = ggplot2::element_blank(),
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank(),
    axis.line = ggplot2::element_line(color = "black")
  )
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *GGally*[@GGally] fornece a função [*ggpairs*](https://www.rdocumentation.org/packages/GGally/versions/2.2.1/topics/ggpairs) para criar uma matriz gráfica de correlações bivariadas.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *car*[@car] fornece a função [*vif*](https://www.rdocumentation.org/packages/car/versions/3.1-3/topics/vif) para calcular o fator de inflação da variância (VIF).
:::

<br>

### O que fazer em caso de multicolinearidade elevada?

-   Verifique a transformação (codificação) de variáveis numéricas em categóricas.[@Kim2019]

-   Aumente o tamanho da amostra, se possível, para reduzir a multicolinearidade.[@Kim2019]

-   Combine níveis de variáveis categóricas com baixa frequência de ocorrência.[@Kim2019]

-   Combine variáveis numéricas altamente correlacionadas em uma única variável composta, como a média ou soma das variáveis.[@Kim2019]

-   Considere a exclusão de variáveis altamente correlacionadas do modelo, especialmente se elas não forem essenciais para a análise.[@Kim2019]

-   Use técnicas de seleção de variáveis, como seleção passo a passo, para identificar e remover variáveis redundantes.[@Kim2019]

-   Use técnicas de regularização, como regressão ridge ou LASSO, que podem lidar com multicolinearidade ao penalizar coeficientes de regressão.[@Kim2019]

<br>

## Redução de dimensionalidade

<br>

### Correlação bivariada pode ser usada para seleção de variáveis em modelos de regressão multivariável?

-   Seleção bivariada de variáveis --- isto é, aplicação de testes de correlação em pares de variáveis candidatas e variável de desfecho afim de selecionar quais serão incluídas no modelo multivariável --- é um dos erros mais comuns na literatura.[@Dales1978; @Sun1996; @heinze2016]

-   A seleção bivariada de variáveis torna o modelo mais suscetível a otimismo no ajuste se as variáveis de confundimento não são adequadamente controladas.[@Dales1978; @Sun1996]

<br>

### Variáveis sem significância estatística devem ser excluídas do modelo final?

-   Eliminar uma variável de um modelo significa anular o seu coeficiente de regressão ($\beta = 0$), mesmo que o valor estimado pelos dados seja outro. Desta forma, os resultados se afastam de uma solução de máxima verossimilhança (que tem fundamento teórico) e o modelo resultante é intencionalmente subótimo.[@heinze2016]

-   Os coeficientes de regressão geralmente dependem do conjunto de variáveis do modelo e, portanto, podem mudam de valor ("mudança na estimativa" positiva ou negativa) se uma (ou mais) variável(is) for(em) eliminada(s) do modelo.[@heinze2016]

<br>

### Por que métodos de regressão gradual não são recomendados para seleção de variáveis em modelos de regressão multivariável?

-   Métodos diferentes de regressão gradual podem produzir diferentes seleções de variáveis de um mesmo banco de dados.[@Healy1995]

-   Nenhum método de regressão gradual garante a seleção ótima de variáveis de um banco de dados.[@Healy1995]

-   As regras de término da regressão baseadas em P-valor tendem a ser arbitrárias.[@Healy1995]

<br>

### O que pode ser feito para reduzir o número de variáveis candidatas em modelos de regressão multivariável?

-   Em caso de uma proporção baixa entre o número de participantes e de variáveis, use o conhecimento prévio da literatura para selecionar um pequeno conjunto de variáveis candidatas.[@Sun1996]

-   Colapse categorias com contagem nula (células com valor igual a 0) de variáveis candidatas.[@Sun1996]

-   Use simulações de dados para identificar qual(is) variável(is) está(ão) causando problemas de convergência do ajuste do modelo.[@Sun1996]

-   A eliminação retroativa tem sido recomendada como a abordagem de regressão gradual mais confiável entre aquelas que podem ser facilmente alcançadas com programas de computador.[@heinze2016]

<br>

### Quando devemos forçar uma variável no modelo?

-   Sempre que houver base teórica ou evidência prévia forte, ou se for a variável de exposição principal.[@Greenland1989]

<br>

## Seleção de variáveis em regressão

<br>

### O que é seleção de variáveis em regressão?

-   Seleção de variáveis em regressão consiste em identificar, dentre um conjunto de preditores disponíveis, quais devem ser incluídos no modelo para otimizar o equilíbrio entre ajuste e parcimônia.[@lindsey2011]

<br>

### Quais são os principais critérios de informação usados na seleção de variáveis?

-   Critérios de informação avaliam o ajuste do modelo penalizando a complexidade (número de preditores), ajudando a evitar *overfitting*.[@lindsey2011]

-   $R^2_{adj}$ \@ref(eq:R2-ajustado) penaliza o $R^2$ pelo número de preditores, reduzindo o viés em modelos com muitas variáveis, onde $n$ é o tamanho amostral, $k$ o número de preditores, $RSS$ a soma dos quadrados dos resíduos e $SST$ a soma total dos quadrados.

<br>

\begin{equation}
(\#eq:R2-ajustado)
R^2_{adj} = 1 - \frac{(n-1)}{(n - k - 1)} \cdot \frac{RSS}{SST}
\end{equation}

<br>

-   $AIC$ (Akaike Information Criterion) \@ref(eq:AIC) mede o equilíbrio entre ajuste e complexidade:

<br>

\begin{equation}
(\#eq:AIC)
AIC = n \cdot \log\left(\frac{RSS}{n}\right) + 2k + n + n \cdot \log(2\pi)
\end{equation}

<br>

-   $AICc$ \@ref(eq:AICc) é uma versão corrigida do AIC, preferida para amostras pequenas:

<br>

\begin{equation}
(\#eq:AICc)
AIC_c = AIC + \frac{2(k+2)(k+3)}{n - (k + 2) - 1}
\end{equation}

<br>

-   $C_p$ de Mallows compara o erro do modelo reduzido com o modelo completo, idealmente satisfazendo $C_p \approx p$, onde $m$ é o número total de preditores disponíveis, $p$ o número de parâmetros (incluindo o intercepto), e $RSS_{FULL}$ o erro quadrático residual do modelo completo:

<br>

\begin{equation}
(\#eq:Cp)
C_p = (n - m - 1)\frac{RSS}{RSS_{FULL}} - (n - 2p)
\end{equation}

<br>

-   $BIC$ (Bayesian Information Criterion) \@ref(eq:BIC) penaliza fortemente modelos complexos:

<br>

\begin{equation}
(\#eq:BIC)
BIC = n \cdot \log\left(\frac{RSS}{n}\right) + k \cdot \log(n) + n + n \cdot \log(2\pi)
\end{equation}

<br>

### Quais algoritmos podem ser usados para seleção automática?

-   Seleção progressiva (*forward selection*): começa com o modelo nulo e adiciona, a cada iteração, a variável que mais melhora o critério escolhido. O processo para quando nenhuma nova variável melhora o modelo.[@lindsey2011]

-   Eliminação retrógrada (*backward elimination*): parte do modelo completo e remove, a cada iteração, a variável cuja exclusão mais melhora o critério. O processo para quando nenhuma remoção melhora o ajuste.[@lindsey2011]

-   *Leaps-and-bounds*: método exato que examina apenas uma fração dos $2^m$ modelos possíveis, determinando os melhores subconjuntos para cada tamanho de preditor (usando os critérios AIC, BIC, AICc, R² ajustado e Cp).[@lindsey2011]

-   Esses métodos podem divergir em presença de alta multicolinearidade ou amostras pequenas, e devem ser acompanhados de diagnóstico de resíduos e validação cruzada.[@lindsey2011]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *leaps*[@leaps] fornece a função [*regsubsets*](https://www.rdocumentation.org/packages/leaps/versions/3.1/topics/regsubsets) para realizar os métodos de seleção de variáveis.
:::

<br>

## Suposições dos modelos de regressão

<br>

### Quais suposições são feitas para regressão?

-   As suposições dos modelos de regressão incluem linearidade, independência, homocedasticidade, normalidade dos resíduos e ausência de multicolinearidade.[@REF]

<br>

### Como avaliar as suposições de uma regressão?

-   Usando diagnóstico de regressão (ex.: análise de resíduos, gráficos de valores observados vs. preditos) e comparação com análises estratificadas.[@Greenland1989]

<br>

```{r suposicoes, include = TRUE, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Diagnóstico de regressão para avaliar suposições do modelo: linearidade, normalidade dos resíduos, homocedasticidade e alavancagem."}
library(dplyr)

# Definir semente
set.seed(123)

# Simular dados
n <- 100
x1 <- stats::rnorm(n, mean = 50, sd = 10)
x2 <- stats::rnorm(n, mean = 30, sd = 5)
erro <- stats::rnorm(n, mean = 0, sd = 5)
y <- 10 + 0.5 * x1 - 0.3 * x2 + erro

# Data frame
dados <- data.frame(y = y, x1 = x1, x2 = x2)

# Modelo
modelo <- stats::lm(y ~ x1 + x2, data = dados)

# Dados auxiliares para gráficos
dados_diag <- dados %>%
  dplyr::mutate(
    Ajustado = stats::fitted(modelo),
    Resíduo = stats::resid(modelo),
    Resíduo_pad = stats::rstandard(modelo),
    Raiz_Resíduo_pad = sqrt(abs(Resíduo_pad)),
    Cook = stats::cooks.distance(modelo),
    Alavancagem = stats::hatvalues(modelo)
  )

# Gráfico 1: Resíduos vs Ajustados
g1 <- ggplot2::ggplot(dados_diag, ggplot2::aes(x = Ajustado, y = Resíduo)) +
  ggplot2::geom_point(color = "blue") +
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  ggplot2::labs(title = "Resíduos vs Ajustados", subtitle = "--- Resíduo = 0",
                x = "Valores Ajustados", y = "Resíduos") +
  ggplot2::theme_minimal()

# Gráfico 2: QQ Plot
g2 <- ggplot2::ggplot(dados_diag, ggplot2::aes(sample = Resíduo)) +
  ggplot2::stat_qq(color = "darkgreen") +
  ggplot2::stat_qq_line(color = "black", linetype = "dashed") +
  ggplot2::labs(title = "Normal Q-Q", subtitle = "--- Distribuição Normal Teórica",
                x = "Quantis Teóricos", y = "Resíduos") +
  ggplot2::theme_minimal()

# Gráfico 3: Scale-Location
g3 <- ggplot2::ggplot(dados_diag, ggplot2::aes(x = Ajustado, y = Raiz_Resíduo_pad)) +
  ggplot2::geom_point(color = "orange") +
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  ggplot2::labs(title = "Scale-Location", subtitle = "--- Referência visual",
                x = "Valores Ajustados", y = "√|Resíduos Padronizados|") +
  ggplot2::theme_minimal()

# Gráfico 4: Distância de Cook
g4 <- ggplot2::ggplot(dados_diag, ggplot2::aes(x = seq_along(Cook), y = Cook)) +
  ggplot2::geom_segment(ggplot2::aes(xend = seq_along(Cook), yend = 0), color = "purple") +
  ggplot2::geom_hline(yintercept = 4/n, linetype = "dashed", color = "black") +
  ggplot2::labs(title = "Distância de Cook", subtitle = "--- Limite sugerido (4/n)",
                x = "Observação", y = "Distância") +
  ggplot2::theme_minimal()

# Gráfico 5: Observado vs Ajustado
lim <- range(c(dados_diag$y, dados_diag$Ajustado))
g5 <- ggplot2::ggplot(dados_diag, ggplot2::aes(x = y, y = Ajustado)) +
  ggplot2::geom_point(color = "darkblue") +
  ggplot2::geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +
  ggplot2::coord_cartesian(xlim = lim, ylim = lim) +
  ggplot2::labs(title = "Observado vs Ajustado", subtitle = "--- y = x",
                x = "Valores Observados", y = "Valores Ajustados") +
  ggplot2::theme_minimal()

# Gráfico 6: Alavancagem
g6 <- ggplot2::ggplot(dados_diag, ggplot2::aes(x = seq_along(Alavancagem), y = Alavancagem)) +
  ggplot2::geom_point(color = "darkred") +
  ggplot2::geom_hline(yintercept = 2 * mean(dados_diag$Alavancagem), linetype = "dashed", color = "black") +
  ggplot2::labs(title = "Alavancagem", subtitle = "--- 2 × média",
                x = "Observação", y = "Valores de Alavancagem") +
  ggplot2::theme_minimal()

# Organizar os 6 gráficos em 2x3
gridExtra::grid.arrange(g1, g2, g3, g4, g5, g6, nrow = 2)
```

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
