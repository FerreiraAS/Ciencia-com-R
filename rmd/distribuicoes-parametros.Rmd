# **Distribuições e parâmetros** {#distribuicoes-parametros}

<br>

## Distribuições de probabilidade

<br>

### O que são distribuições de probabilidade?

-   Uma distribuição de probabilidade é uma função que descreve os valores possíveis ou o intervalo de valores de uma variável (eixo horizontal) e a frequência com que cada valor é observado (eixo vertical).[@vetter2017]

<br>

### Como representar distribuições de probabilidade?

-   Tabelas de frequência, polígonos de frequência, gráficos de barras, histogramas e *boxplots* são formas de representar distribuições de probabilidade.[@s2011]

-   Tabelas de frequência mostram as categorias de medição e o número de observações em cada uma. É necessário conhecer o intervalo de valores (mínimo e máximo), que é dividido em intervalos arbitrários chamados "intervalos de classe".[@s2011]

-   Se houver muitos intervalos, não haverá redução significativa na quantidade de dados, e pequenas variações serão perceptíveis. Se houver poucos intervalos, a forma da distribuição não poderá ser adequadamente determinada.[@s2011]

-   A quantidade de intervalos pode ser determinada pelo método de Sturges, que é dado pela fórmula $k = 1 + 3.322 \times \log_{10}(n)$, onde $k$ é o número de intervalos e $n$ é o número de observações.[@sturges1926]

-   A quantidade de intervalos pode ser determinada pelo método de Scott, que é dado pela fórmula $h = 3.5 \times \text{sd}(x) \times n^{-1/3}$, onde $h$ é a largura do intervalo, $\text{sd}(x)$ é o desvio padrão e $n$ é o número de observações.[@scott1979]

-   A quantidade de intervalos pode ser determinada pelo método de Freedman-Diaconis, que é dado pela fórmula $h = 2 \times \text{IQR}(x) \times n^{-1/3}$, onde $h$ é a largura do intervalo, $\text{IQR}(x)$ é o intervalo interquartil e $n$ é o número de observações.[@freedman1981]

-   A largura das classes pode ser determinada dividindo o intervalo total de observações pelo número de classes. Recomenda-se larguras iguais, mas larguras desiguais podem ser usadas quando existirem grandes lacunas nos dados ou em contextos específicos. Os intervalos devem ser mutuamente exclusivos e não sobrepostos, evitando intervalos abertos (ex.: \<5, \>10).[@s2011]

-   Polígonos de frequência são gráficos de linhas que conectam os pontos médios de cada barra do histograma. Eles são úteis para comparar duas ou mais distribuições de frequência.[@s2011]

-   Gráficos de barra verticais ou horizontais representam a distribuição de frequências de uma variável categórica. A altura de cada barra é proporcional à frequência da classe. A largura da barra é igual à largura da classe. A área de cada barra é proporcional à frequência da classe. A área total do gráfico de barras é igual ao número total de observações.[@s2011]

-   Histogramas representam a distribuição de frequências de uma variável contínua. A altura de cada barra é proporcional à frequência da classe. A largura da barra é igual à largura da classe. A área de cada barra é proporcional à frequência da classe. A área total do histograma é igual ao número total de observações.[@s2011]

-   *Boxplots* representam a distribuição de frequências de uma variável contínua. A linha central divide os dados em duas partes iguais (mediana ou Q2). A caixa inferior representa o primeiro quartil (Q1) e a caixa superior representa o terceiro quartil (Q3). A linha inferior é o mínimo e a linha superior é o máximo. Os valores atípicos são representados por pontos individuais.[@s2011]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *grDevices*[@grDevices] fornece a função [nclass](https://www.rdocumentation.org/packages/grDevices/versions/3.6.2/topics/nclass) para determinar a quantidade de classes de um histograma com os métodos de Sturge[@sturges1926], Scott[@scott1979] ou Freedman-Diaconis[@freedman1981].
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *ggplot2*[@ggplot2] fornece a função [geom_freqpoly](https://www.rdocumentation.org/packages/ggplot2/versions/3.5.2/topics/geom_freqpoly) para criar histogramas.
:::

<br>

### Quais características definem uma distribuição?

-   Uma distribuição pode ser definida por modelos matemáticos e caracterizada por parâmetros de tendência central, dispersão, simetria e curtose.

<br>

### Quais são as distribuições mais comuns?

-   Distribuções discretas:

    -   Bernoulli: resultado de um único teste com dois possíveis desfechos (sucesso ou fracasso).[@REF]

    -   Binomial: número de sucessos em *k* tentativas. [@REF]

    -   Geométrica: número de testes até o 1o sucesso.[@REF]

    -   Binomial negativa: número de testes até o *k*-ésimo sucesso.[@REF]

    -   Hipergeométrica: número de indivíduos na amostra tomados sem reposição. [@REF]

    -   Poisson: número de eventos em um intervalo de tempo fixo.[@REF]

    -   Uniforme: resultados (finitos) que são igualmente prováveis. [@REF]

    -   Multinomial: resultados de múltiplos testes com mais de dois possíveis desfechos. [@REF]

<br>

```{r distribuicao-discreta, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições discretas e suas funções de probabilidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 1. Distribuição Bernoulli (p = 0.5)
bernoulli_data <- rbinom(1000, 1, 0.5)
p1 <- ggplot2::ggplot(data.frame(bernoulli_data), ggplot2::aes(x = bernoulli_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Bernoulli", x = "Resultado", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 2. Distribuição Binomial (n = 10, p = 0.5)
binomial_data <- rbinom(1000, 10, 0.5)
p2 <- ggplot2::ggplot(data.frame(binomial_data), ggplot2::aes(x = binomial_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Binomial", x = "Sucessos", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 3. Distribuição Geométrica (p = 0.5)
geom_data <- rgeom(1000, 0.5) # número de tentativas até o 1º sucesso com p = 0.5
p3 <- ggplot2::ggplot(data.frame(geom_data), ggplot2::aes(x = geom_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Geométrica", x = "Tentativas até o Sucesso", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 4. Distribuição Binomial Negativa (r = 3, p = 0.5)
neg_binomial_data <- rnbinom(1000, 3, 0.5)
p4 <- ggplot2::ggplot(data.frame(neg_binomial_data),
                      ggplot2::aes(x = neg_binomial_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Binomial Negativa", x = "Tentativas até o 3º Sucesso", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 5. Distribuição Hipergeométrica (m = 10, n = 30, k = 5)
hypergeom_data <- rhyper(1000, 10, 30, 5)
p5 <- ggplot2::ggplot(data.frame(hypergeom_data), ggplot2::aes(x = hypergeom_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Hipergeométrica", x = "Sucessos", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 6. Distribuição Poisson (lambda = 3)
poisson_data <- rpois(1000, 3)
p6 <- ggplot2::ggplot(data.frame(poisson_data), ggplot2::aes(x = poisson_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Poisson", x = "Eventos", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 7. Distribuição Uniforme Discreta (min = 1, max = 6)
uniform_data <- sample(1:6, 1000, replace = TRUE)
p7 <- ggplot2::ggplot(data.frame(uniform_data), ggplot2::aes(x = uniform_data)) +
  ggplot2::geom_bar(stat = "count", fill = cor_padrao) +
  ggplot2::labs(title = "Uniforme Discreta", x = "Resultado", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 8. Distribuição Multinomial (probabilidades: 1/3, 1/3, 1/3)
# Gerar 1000 experimentos com 3 resultados possíveis e 10 tentativas em cada experimento
multinomial_data <- rmultinom(1000, 10, prob = c(1 / 3, 1 / 3, 1 / 3))

# Convertendo os dados para um formato adequado para ggplot
multinomial_df <- data.frame(Result = rep(1:3, times = 1000),
                             Freq = as.vector(multinomial_data))

# Criando o gráfico
p8 <- ggplot2::ggplot(multinomial_df, ggplot2::aes(x = factor(Result), y = Freq)) +
  ggplot2::geom_bar(stat = "identity", fill = cor_padrao) +
  ggplot2::labs(title = "Multinomial", x = "Resultado", y = "Frequência") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 2x4 com todos os gráficos
gridExtra::grid.arrange(p1, p2, p3, p4, p5, p6, p7, p8, ncol = 4, nrow = 2)
```

<br>

-   Distribuições contínuas:

    -   Uniforme: .[@REF]

    -   Exponencial: .[@REF]

    -   Normal: .[@REF]

    -   Aproximação binomial: .[@REF]

    -   Aproximação Poisson: .[@REF]

    -   t-Student: .[@REF]

    -   Qui-quadrado: .[@REF]

    -   Weibull: .[@REF]

    -   Gama: .[@REF]

    -   Log-normal: .[@REF]

    -   Beta: .[@REF]

    -   Logística: .[@REF]

    -   Pareto. [@REF]

<br>

```{r distribuicao-basica, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas básicas e suas funções de densidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 1. Distribuição Uniforme (a = 0, b = 1)
uniforme_data <- runif(1000000, min = 0, max = 1)
p1 <- ggplot2::ggplot(data.frame(uniforme_data), ggplot2::aes(x = uniforme_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Uniforme", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 2. Distribuição Exponencial (lambda = 1)
exponencial_data <- rexp(1000000, rate = 1)
p2 <- ggplot2::ggplot(data.frame(exponencial_data),
                      ggplot2::aes(x = exponencial_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Exponencial", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 1x2 com os gráficos p1 e p2
gridExtra::grid.arrange(p1, p2, ncol = 2, nrow = 1)
```

<br>

```{r distribuicao-simetricas, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas aproximadas e suas funções de densidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 3. Distribuição Normal (mu = 0, sigma = 1)
normal_data <- rnorm(100000, mean = 0, sd = 1)
p3 <- ggplot2::ggplot(data.frame(normal_data), ggplot2::aes(x = normal_data)) +
ggdist::stat_halfeye(fill = cor_padrao,
color = "black",
alpha = 0.7) +
ggplot2::labs(title = "Normal", x = "Valor", y = "Densidade") +
ggplot2::theme_minimal() +
ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 1x1 com os gráficos p1
gridExtra::grid.arrange(p3, ncol = 1, nrow = 1)
```

<br>

```{r distribuicao-aproximada, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas aproximadas e suas funções de densidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 4. Aproximação Binomial (n = 100, p = 0.5)
binomial_data <- rbinom(100000, size = 100, prob = 0.5)
p4 <- ggplot2::ggplot(data.frame(binomial_data), ggplot2::aes(x = binomial_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Aproximação Binomial", x = "Sucessos", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 5. Aproximação Poisson (lambda = 5)
poisson_data <- rpois(100000, lambda = 5)
p5 <- ggplot2::ggplot(data.frame(poisson_data), ggplot2::aes(x = poisson_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Poisson", x = "Ocorrências", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 1x2 com os gráficos p4 e p5
gridExtra::grid.arrange(p4, p5, ncol = 2, nrow = 1)
```

<br>

```{r distribuicao-inferencia, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas para inferência e suas funções de densidade."}
# Reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 6. Distribuição t-Student (df = 10)
tstudent_data <- rt(100000, df = 10)
p6 <- ggplot2::ggplot(data.frame(tstudent_data), ggplot2::aes(x = tstudent_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "t-Student", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 7. Distribuição Qui-Quadrado (df = 10)
chi_squared_data <- rchisq(100000, df = 10)
p7 <- ggplot2::ggplot(data.frame(chi_squared_data),
                      ggplot2::aes(x = chi_squared_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Qui-Quadrado", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 1x2 com os gráficos p6 e p7
gridExtra::grid.arrange(p6, p7, ncol = 2, nrow = 1)
```

<br>

```{r distribuicao-especificos, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas para dados específicos e suas funções de densidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 8. Distribuição Weibull (shape = 1.5, scale = 1)
weibull_data <- rweibull(100000, shape = 1.5, scale = 1)
p8 <- ggplot2::ggplot(data.frame(weibull_data), ggplot2::aes(x = weibull_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Weibull", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 9. Distribuição Gama (shape = 5, scale = 1)
gama_data <- rgamma(100000, shape = 5, scale = 1)
p9 <- ggplot2::ggplot(data.frame(gama_data), ggplot2::aes(x = gama_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Gama", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 10. Distribuição Log-Normal (meanlog = 0, sdlog = 1)
log_normal_data <- rlnorm(100000, meanlog = 0, sdlog = 1)
p10 <- ggplot2::ggplot(data.frame(log_normal_data),
                       ggplot2::aes(x = log_normal_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Log-Normal", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 2x2 com os gráficos p8, p9 e p10
gridExtra::grid.arrange(p8, p9, p10, ncol = 3, nrow = 1)
```

<br>

```{r distribuicao-proporcoes, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas para probabilidades e proporções e suas funções de densidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 11. Distribuição Beta (alpha = 2, beta = 5)
beta_data <- rbeta(100000, shape1 = 2, shape2 = 5)
p11 <- ggplot2::ggplot(data.frame(beta_data), ggplot2::aes(x = beta_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Beta", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# 12. Distribuição Logística (mu = 0, s = 1)
logistica_data <- rlogis(100000, location = 0, scale = 1)
p12 <- ggplot2::ggplot(data.frame(logistica_data), ggplot2::aes(x = logistica_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Logística", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 2x2 com os gráficos p11 e p12
gridExtra::grid.arrange(p11, p12, ncol = 2, nrow = 1)
```

<br>

```{r distribuicao-pareto, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições contínuas com caudas pesadas e suas funções de densidade."}
# Definir semente para reprodutibilidade
set.seed(42)

# Definir cor padrão para os gráficos
cor_padrao <- "lightblue"

# 13. Distribuição Pareto (shape = 2, scale = 1)
# Gerar a distribuição Pareto usando a função rpareto
pareto_data <- actuar::rpareto(100, shape = 2, scale = 1)
p13 <- ggplot2::ggplot(data.frame(pareto_data), ggplot2::aes(x = pareto_data)) +
  ggdist::stat_halfeye(fill = cor_padrao,
                       color = "black",
                       alpha = 0.7) +
  ggplot2::labs(title = "Pareto", x = "Valor", y = "Densidade") +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 8))

# Criar painel 1x1 com os gráficos p13
gridExtra::grid.arrange(p13, ncol = 1, nrow = 1)
```

<br>

### Quais são as funções de uma distribuição?

-   Função de massa de probabilidade (*probability mass function*, pmf).[@REF]

-   Função de distribuição cumulativa (*cumulative distribution function*, cdf).[@REF]

-   Função quantílicas (*quantile function*, qf).[@REF]

-   Função geradora de números aleatórios (*random function*, rf).[@REF]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *stats*[@stats] fornece funções de distribuição de probabilidade (p), funções de densidade (d), funções quantílicas (q) e funções geradores de números aleatórios (r) para as distribuições [normal](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/Normal), [Student t](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/TDist), [binomial](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/Binomial), [qui-quadrado](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/Chisquare), [uniforme](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/Uniform), dentre outras.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *ggdist*[@ggdist] fornece a função [geom_slabinterval](https://www.rdocumentation.org/packages/ggdist/versions/3.3.0/topics/geom_slabinterval) para criar gráficos de distribuição de probabilidade (p) e funções de densidade (d) as distribuições.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *ggfortify*[@ggfortify] fornece a função [ggdistribution](https://www.rdocumentation.org/packages/ggfortify/versions/0.4.16/topics/ggdistribution) para criar gráficos de distribuição de probabilidade (p), funções de densidade (d), funções quantílicas (q) e funções geradores de números aleatórios (r) para as distribuições.
:::

<br>

### O que é a distribuição normal?

-   A distribuição normal (ou gaussiana) é uma distribuição com desvios simétricos positivos e negativos em torno de um valor central.[@Ali2016]

-   Em uma distribuição normal, o intervalo de 1 desvio-padrão (±1DP) inclui cerca de 68% dos dados; de 2 desvios-padrão (±2DP) cerca de 95% dos dados; e no intervalo de 3 desvios-padrão (±3DP) cerca de 99% dos dados.[@Ali2016]

<br>

```{r distribuicao-normal, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições e funções de probabilidade."}
scaleFUN <- function(x)
  sprintf("%.2f", x)

# normal
d1 <- ggfortify::ggdistribution(dnorm,
                                seq(-3, 3, 0.1),
                                mean = 0,
                                sd = 1,
                                main = "Distribuição de probabilidade") + ggplot2::scale_y_continuous(labels = scaleFUN) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

p1 <- ggfortify::ggdistribution(pnorm,
                                seq(-3, 3, 0.1),
                                mean = 0,
                                sd = 1,
                                main = "Função de distribuição cumulativa") + ggplot2::scale_y_continuous(labels = scaleFUN) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

ggpubr::ggarrange(
  d1,
  p1,
  heights = c(1, 1),
  widths = c(1, 1),
  nrow = 1,
  ncol = 2,
  align = "h"
)
```

<br>

### Que métodos podem ser utilizados para identificar a normalidade da distribuição?

-   Histogramas.[@vetter2017]

-   Gráficos Q-Q.[@vetter2017]

-   Testes de hipótese nula:[@vetter2017]

    -   Kolmogorov-Smirnov

    -   Shapiro-Wilk

    -   Anderson-Darling

<br>

```{r normalidade-distribuicao, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuição normal e métodos de visualização e testes de normalidade."}
scaleFUN <- function(x)
  sprintf("%.2f", x)

# Simulate random sample from normal distribution
set.seed(123)
n <- 50
data <- rnorm(n, mean = 0, sd = 1)

# Calcular a média e o desvio padrão
mean_data <- mean(data)
sd_data <- sd(data)

# Realizar os testes
ks_test <- ks.test(data, "pnorm", mean = 0, sd = 1)
shapiro_test <- shapiro.test(data)
ad_test <- nortest::ad.test(data)

# Função para formatar p-values
format_p_value <- function(p_value) {
  if (p_value < 0.001) {
    return("p < 0.001")
  } else {
    return(paste("p-value:", format(p_value, digits = 4)))
  }
}

# Normal Distribution plot (d1) com média e desvio padrão no título
d1 <- ggfortify::ggdistribution(
  dnorm,
  seq(-3, 3, 0.1),
  mean = 0,
  sd = 1,
  main = paste(
    "Distribuição de probabilidade\nMédia:",
    sprintf("%.2f", mean_data),
    "Desvio Padrão:",
    sprintf("%.2f", sd_data)
  )
) +
  ggplot2::scale_y_continuous(labels = scaleFUN) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

# CDF plot (p1)
p1 <- ggfortify::ggdistribution(pnorm,
                                seq(-3, 3, 0.1),
                                mean = 0,
                                sd = 1,
                                main = "Função de distribuição cumulativa") +
  ggplot2::scale_y_continuous(labels = scaleFUN) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

# QQ-plot for Normal distribution
qqplot <- ggplot2::ggplot(data.frame(x = data), ggplot2::aes(sample = x)) +
  ggplot2::stat_qq() +
  ggplot2::stat_qq_line(color = "red") +
  ggplot2::ggtitle("QQ-Plot") +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

# Kolmogorov-Smirnov Test plot (kolmogorov)
kolmogorov <- ggplot2::ggplot(data.frame(x = sort(data)), ggplot2::aes(x)) +
  ggplot2::stat_ecdf(geom = "step", color = "blue") +  # ECDF of data
  ggplot2::stat_function(
    fun = stats::pnorm,
    args = list(mean = 0, sd = 1),
    color = "red",
    size = 1
  ) +
  ggplot2::ggtitle(paste("Kolmogorov-Smirnov Test\n", format_p_value(ks_test$p.value))) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

# Shapiro-Wilk Test plot (shapiro)
shapiro <- ggplot2::ggplot(data.frame(x = sort(data)), ggplot2::aes(x)) +
  ggplot2::stat_ecdf(geom = "step", color = "green") +  # ECDF of data
  ggplot2::stat_function(
    fun = stats::pnorm,
    args = list(mean = 0, sd = 1),
    color = "red",
    size = 1
  ) +
  ggplot2::ggtitle(paste("Shapiro-Wilk Test\n", format_p_value(shapiro_test$p.value))) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

# Anderson-Darling Test plot (anderson)
anderson <- ggplot2::ggplot(data.frame(x = sort(data)), ggplot2::aes(x)) +
  ggplot2::stat_ecdf(geom = "step", color = "purple") +  # ECDF of data
  ggplot2::stat_function(
    fun = stats::pnorm,
    args = list(mean = 0, sd = 1),
    color = "red",
    size = 1
  ) +  # Normal CDF
  ggplot2::ggtitle(paste("Anderson-Darling Test\n", format_p_value(ad_test$p.value))) +
  ggplot2::theme_minimal() +
  ggplot2::theme(aspect.ratio = 1,
                 text = ggplot2::element_text(size = 8))

# Combine all plots into one grid
ggpubr::ggarrange(
  d1,
  p1,
  qqplot,
  kolmogorov,
  shapiro,
  anderson,
  heights = c(1, 1),
  widths = c(1, 1, 1),
  nrow = 2,
  ncol = 3,
  align = "h"
)
```

<br>

### O que são distribuições não-normais?

-   .[@REF]

<br>

## Parâmetros

<br>

### O que são parâmetros?

-   Parâmetros são informações que definem um modelo teórico, como propriedades de uma coleção de indivíduos.[@Altman1999]

-   Parâmetros definem características de uma população inteira, tipicamente não observados por ser inviável ter acesso a todos os indivíduos que constituem tal população.[@vetter2017]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *base*[@base] fornece a função [*summary*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) para calcular diversos parâmetros descritivos.
:::

<br>

### O que é uma análise paramétrica?

-   Testes paramétricos possuem suposições sobre as características e/ou parâmetros da distribuição dos dados na população.[@vetter2017]

-   Testes paramétricos assumem que: a variável é quantitativa numérica (contínua); os dados foram amostrados de uma população com distribuição normal; a variância da(S) amostra(s) é igual à da população; as amostras foram selecionadas de modo aleatório na população; os valores de cada amostra são independentes entre si.[@Ali2016; @vetter2017]

-   Testes paramétricos são baseados na suposição de que os dados amostrais provêm de uma população com parâmetros fixos determinando sua distribuição de probabilidade.[@kwak2017]

<br>

### O que é uma análise não paramétrica?

-   Testes não-paramétricos fazem poucas suposições, ou menos rigorosas, sobre as características e/ou parâmetros da distribuição dos dados na população.[@Ali2016; @vetter2017]

-   Testes não-paramétricos são úteis quando as suposições de normalidade não podem ser sustentadas.[@Ali2016]

<br>

### Devemos testar as suposições de normalidade?

-   Testes preliminares de normalidade não são necessários para a maioria dos testes paramétricos de comparação, pois eles são robustos contra desvios moderados da normalidade. Normalidade da distribuição deve ser estabelecida para a população. [@rochon2012]

<br>

### Por que as análises paramétricas são preferidas?

-   Em geral, testes paramétricos são mais robustos (isto é, possuem menores erros tipo I e II) que seus testes não-paramétricos correspondentes.[@greenhalgh1997; @schmider2010; @vetter2017]

-   Testes não-paramétricos apresentam menor poder estatístico (maior erro tipo II) comparados aos testes paramétricos correspondentes.[@Ali2016]

<br>

### Que parâmetros podem ser estimados?

-   Parâmetros de tendência central.[@kanji2006; @Ali2016]

-   Parâmetros de dispersão.[@kanji2006; @Ali2016; @Curran-Everett2008]

-   Parâmetros de proporção.[@Altman1994; @kanji2006; @Ali2016; @Altman1994]

-   Parâmetros de distribuição.[@kanji2006]

-   Parâmetros de extremos.[@Ali2016]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *base*[@base] fornece a função [*summary*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) para calcular diversos parâmetros descritivos.
:::

<br>

## Tendência central

<br>

### Que parâmetros de tendência central podem ser estimados?

-   Média aritmética, ponderada, geométrica ou harmônica.[@kanji2006; @Ali2016; @s.2011a]

-   Mediana.[@kanji2006; @Ali2016; @s.2011]

-   Moda.[@kanji2006; @Ali2016; @s.2011]

-   A posição relativa das medidas de tendência central (média, mediana e moda) depende da forma da distribuição.[@s.2011]

-   Em uma distribuição normal, as três medidas são idênticas.[@s.2011]

-   A média é sempre puxada para os valores extremos, por isso é deslocada para a cauda em distribuições assimétricas.[@s.2011]

-   A mediana fica entre a média e a moda em distribuições assimétricas.[@s.2011]

-   A moda é o valor mais frequente e, portanto, se localiza no pico da distribuição assimétrica.[@s.2011]

-   Uma distribuição pode uma moda (unimodal), duas modas (bimodal) ou três ou mais modas (multimodal), indicando a presença de mais de um valor com alta frequência.[@s.2011]

<br>

```{r distribuicoes-unimodal-bimodal-multimodal, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Distribuições unimodal, bimodal e multimodal."}
# Reprodutibilidade
set.seed(42)

# Cor padrão
cor_padrao <- "lightblue"

# 1. Unimodal
dados_uni <- rnorm(100000, mean = 0, sd = 1)
df_uni <- data.frame(valor = dados_uni, grupo = "Unimodal")

# 2. Bimodal
dados_bi <- c(rnorm(50000, mean = -1, sd = 0.8), rnorm(50000, mean = 1, sd = 0.8))
df_bi <- data.frame(valor = dados_bi, grupo = "Bimodal")

# 3. Multimodal
dados_multi <- c(rnorm(33333, mean = -2, sd = 0.5),
                 rnorm(33334, mean = 0, sd = 0.4),
                 rnorm(33333, mean = 2, sd = 0.5))
df_multi <- data.frame(valor = dados_multi, grupo = "Multimodal")

# Juntar os dados
dados_todos <- rbind(df_uni, df_bi, df_multi)

# Reordenar os níveis do fator explicitamente
dados_todos$grupo <- factor(dados_todos$grupo,
                            levels = rev(c("Unimodal", "Bimodal", "Multimodal")))

# Plot com stat_halfeye (sem slab_type)
p <- ggplot2::ggplot(dados_todos, ggplot2::aes(x = valor, y = grupo)) +
  ggdist::stat_halfeye(
    ggplot2::aes(thickness = ggplot2::after_stat(pdf)),
    fill = cor_padrao,
    color = "black",
    alpha = 0.7
  ) +
  ggplot2::labs(
    title = "Distribuições Unimodal, Bimodal e Multimodal",
    x = "Valor", y = NULL
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(text = ggplot2::element_text(size = 9))

# Mostrar gráfico
p
```

<br>

```{r tendencia-central, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Parâmetros de tendência central em distribuições assimétricas e normais."}
# Função para gerar um dataframe com a densidade e os valores de média, mediana e moda
gerar_dados <- function(tipo_dist) {
  set.seed(123)  # Para reprodutibilidade
  n <- 10000
  
  if (tipo_dist == "assimetria_positiva") {
    x <- rlnorm(n, meanlog = 0, sdlog = 0.5)
    titulo <- "Assimetria Positiva"
  } else if (tipo_dist == "normal") {
    x <- rnorm(n, mean = 0, sd = 1)
    titulo <- "Distribuição Normal (Gaussiana)"
  } else if (tipo_dist == "assimetria_negativa") {
    x <- -rlnorm(n, meanlog = 0, sdlog = 0.5)
    titulo <- "Assimetria Negativa"
  }
  
  # Estimar a moda com base no pico da densidade
  d <- density(x)
  moda <- d$x[which.max(d$y)]
  
  data.frame(
    x = x,
    media = mean(x),
    mediana = median(x),
    moda = moda,
    titulo = titulo
  )
}

# Gerar os conjuntos de dados
dados_pos <- gerar_dados("assimetria_positiva")
dados_norm <- gerar_dados("normal")
dados_neg <- gerar_dados("assimetria_negativa")

# Função para plotar cada distribuição
plotar_distribuicao <- function(dados) {
  ggplot2::ggplot(dados, ggplot2::aes(x = x)) +
    ggplot2::geom_density(fill = "lightblue", alpha = 0.6) +
    ggplot2::geom_vline(
      ggplot2::aes(xintercept = media),
      color = "red",
      linetype = "dashed",
      size = 1
    ) +
    ggplot2::geom_vline(
      ggplot2::aes(xintercept = mediana),
      color = "blue",
      linetype = "dotted",
      size = 1
    ) +
    ggplot2::geom_vline(
      ggplot2::aes(xintercept = moda),
      color = "darkgreen",
      linetype = "solid",
      size = 1
    ) +
    ggplot2::labs(
      title = unique(dados$titulo),
      x = "Valor",
      y = "Densidade",
      subtitle = "Vermelho: Média | Azul: Mediana | Verde: Moda"
    ) +
    ggplot2::theme_minimal()
}

# Criar os gráficos individuais
g1 <- plotar_distribuicao(dados_pos)
g2 <- plotar_distribuicao(dados_norm)
g3 <- plotar_distribuicao(dados_neg)

# Combinar os gráficos em um painel
gridExtra::grid.arrange(g1, g2, g3, nrow = 3)
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *base*[@base] fornece a função [*summary*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) para calcular diversos parâmetros descritivos.
:::

<br>

### Como escolher o parâmetro de tendência central?

-   A mediana é preferida à média quando existem poucos valores extremos na distribuição, alguns valores são indeterminados, ou há uma distribuição aberta, ou os dados são medidos em uma escala ordinal.[@s.2011]

-   A moda é preferida quando os dados são medidos em uma escala nominal.[@s.2011]

-   A média geométrica é preferida quando os dados são medidos em uma escala logarítmica.[@s.2011]

<br>

## Dispersão

<br>

### Que parâmetros de dispersão podem ser estimados?

-   Variância.[@kanji2006; @Ali2016]

-   Desvio-padrão: Informam sobre a dispersão da população e são, portanto, úteis como preditores da variação em novas amostras.[@Curran-Everett2008; @krzywinski2013; @manikandan2011]

-   Erro-padrão: Refletem a incerteza na média e sua dependência do tamanho da amostra.[@Curran-Everett2008; @krzywinski2013]

-   Amplitude.[@kanji2006; @Ali2016; @manikandan2011]

-   Intervalo interquartil.[@kanji2006; @Ali2016; @manikandan2011]

-   Intervalo de confiança: Captura a média populacional correspondente ao nível de significância $\alpha$ pré-estabelecido.[@kanji2006; @Cumming2007; @krzywinski2013; @Ali2016]

<br>

```{r dispersao, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Parâmetros de dispersão em distribuições normais."}
# Geração de dados: distribuição normal
set.seed(123)
n <- 200
dados <- rnorm(n, mean = 50, sd = 10)

# Cálculo das medidas
media <- mean(dados)
variancia <- var(dados)
desvio_padrao <- sd(dados)
erro_padrao <- desvio_padrao / sqrt(n)
amplitude <- max(dados) - min(dados)
iqr <- IQR(dados)

# Criar dataframe com os dados
df <- data.frame(valor = dados)

# Plotar histograma com densidade
ggplot2::ggplot(df, ggplot2::aes(x = valor)) +
  ggplot2::geom_histogram(
    ggplot2::aes(y = ..density..),
    bins = 30,
    fill = "lightblue",
    color = "black",
    alpha = 0.6
  ) +
  ggplot2::geom_density(color = "darkblue", size = 1) +
  
  # Média
  ggplot2::geom_vline(ggplot2::aes(xintercept = media, color = "Média"), size = 1.2) +
  
  # Desvio padrão
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = media + desvio_padrao, color = "Desvio Padrão +1σ"),
    size = 1,
    linetype = "dashed"
  ) +
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = media - desvio_padrao, color = "Desvio Padrão -1σ"),
    size = 1,
    linetype = "dashed"
  ) +
  
  # Erro padrão
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = media + erro_padrao, color = "Erro Padrão +SE"),
    size = 1,
    linetype = "dotted"
  ) +
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = media - erro_padrao, color = "Erro Padrão -SE"),
    size = 1,
    linetype = "dotted"
  ) +
  
  # Intervalo interquartil (IQR)
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = quantile(dados, 0.25), color = "Q1 (25%)"),
    size = 1,
    linetype = "dotdash"
  ) +
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = quantile(dados, 0.75), color = "Q3 (75%)"),
    size = 1,
    linetype = "dotdash"
  ) +
  
  # Limites mínimo e máximo (Amplitude)
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = min(dados), color = "Mínimo"),
    size = 0.8,
    linetype = "longdash"
  ) +
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = max(dados), color = "Máximo"),
    size = 0.8,
    linetype = "longdash"
  ) +
  
  # Legenda
  ggplot2::scale_color_manual(
    values = c(
      "Desvio Padrão -1σ" = "orange",
      "Desvio Padrão +1σ" = "orange",
      "Erro Padrão -SE" = "purple",
      "Erro Padrão +SE" = "purple",
      "Q1 (25%)" = "green",
      "Q3 (75%)" = "green",
      "Mínimo" = "black",
      "Máximo" = "black",
      "Média" = "red"
    ),
    breaks = c(
      "Erro Padrão -SE",
      "Erro Padrão +SE",
      "Q1 (25%)",
      "Q3 (75%)",
      "Desvio Padrão -1σ",
      "Desvio Padrão +1σ",
      "Mínimo",
      "Máximo",
      "Média"
    )
  ) +
  
  ggplot2::labs(
    title = "Visualização de Medidas de Dispersão",
    subtitle = paste0(
      "Média = ",
      round(media, 2),
      " | SD = ",
      round(desvio_padrao, 2),
      " | SE = ",
      round(erro_padrao, 2),
      " | Var = ",
      round(variancia, 2),
      " | IQR = ",
      round(iqr, 2),
      " | Amplitude = ",
      round(amplitude, 2)
    ),
    x = "Valor",
    y = "Densidade",
    color = "Medidas de Dispersão"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(legend.position = "bottom")
```

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *base*[@base] fornece a função [*summary*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) para calcular diversos parâmetros descritivos.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *stats*[@stats] fornece a função [*confint*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/confint) para calcular o intervalo de confiança em um nível de significância $\alpha$.
:::

<br>

### Como escolher o parâmetro de dispersão?

<br>

-   Desvio-padrão é apropriado quando a média é utilizada como parâmetro de tendência central em distribuições simétricas.[@manikandan2011]

-   Amplitue ou intervalo interquartil são apropriadas para variáveis ordinais ou distribuições assimétricas.[@manikandan2011]

<br>

### O que é a correção de Bessel para variância?

-   Correção de Bessel é um ajuste feito no denominador da fórmula de variância da amostra --- ou seja, o número de graus de liberdade --- para evitar que a variância amostral seja menor do que a variância populacional.[@sahai1992]

-   A correção de Bessel é feita subtraindo-se 1 do número de observações da amostra, ou seja, $n - 1$.[@sahai1992]

<br>

### Por que a correção de Bessel para variância é importante?

-   A correção de Bessel é importante porque a variância amostral tende a ser menor do que a variância populacional, especialmente em amostras pequenas.[@sahai1992]

-   A correção de Bessel ajuda a garantir que a variância amostral seja uma estimativa mais precisa da variância populacional, o que é fundamental para a validade dos testes estatísticos e das inferências feitas a partir da amostra.[@sahai1992]

<br>

## Proporção

<br>

### Que parâmetros de proporção podem ser estimados?

-   Frequência absoluta.[@Altman1994; @kanji2006; @Ali2016]

-   Frequência relativa.[@Altman1994; @kanji2006; @Ali2016]

-   Percentil.[@Altman1994; @kanji2006; @Ali2016]

-   Quantil: é o ponto de corte que define a divisão da amostra em grupos de tamanhos iguais. Portanto, não se referem aos grupos em si, mas aos valores que os dividem:[@Altman1994]

    -   Tercil: 2 valores que dividem a amostra em 3 grupos de tamanhos iguais.[@Altman1994]

    -   Quartil: 3 valores que dividem a amostra em 4 grupos de tamanhos iguais.[@Altman1994]

    -   Quintil: 4 valores que dividem a amostra em 5 grupos de tamanhos iguais.[@Altman1994]

    -   Decil: 9 valores que dividem a amostra em 10 grupos de tamanhos iguais.[@Altman1994]

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *base*[@base] fornece a função [*summary*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/summary) para calcular diversos parâmetros descritivos.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *base*[@base] fornece a função [*table*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) para calcular proporções.
:::

<br>

::: {.infobox .Rlogo data-latex="{images/Rlogo}"}
O pacote *stats*[@base] fornece a função [*quantile*](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/quantile) para executar análise de percentis.
:::

<br>

## Distribuição

<br>

### Que parâmetros de distribuição podem ser estimados?

-   Assimetria.[@kanji2006]

-   Curtose.[@kanji2006]

<br>

## Extremos

<br>

### O que são valores extremos?

-   Valores extremos podem constituir valores legítimos ou ilegítimos de uma distribuição.[@leys2019]

-   Valores extremos, quando raros ou desproporcionais, podem se tornar discrepantes ou influentes, afetando as análises estatísticas, sendo recomendado uma análise robusta.[@REF]

<br>

### Que parâmetros extremos podem ser estimados?

-   Mínimo.[@Ali2016]

-   Máximo.[@Ali2016]

<br>

```{r regressao-extremos, echo = FALSE, warning = FALSE, message = FALSE, appendix = TRUE, fig.align = 'center', layout='Blank', ph=officer::ph_location_fullsize(), results = "asis", fig.fullwidth = TRUE, fig.cap = "Regressão linear com valores extremos."}
# Reprodutibilidade
set.seed(123)

# 1) Dados "normais"
n <- 100
X <- rnorm(n, mean = 50, sd = 10)
Y <- 5 + 2 * X + rnorm(n, mean = 0, sd = 5)
data <- data.frame(X, Y)

# 2) Injeta valores extremos
X_ext1 <- rnorm(5, mean = 50, sd = 10)
Y_ext1 <- 5 + 2 * X_ext1 + rnorm(5, mean = 0, sd = 25) + 60

X_ext2 <- c(5, 95, 110, -10, 120)
Y_ext2 <- 5 + 2 * X_ext2 + rnorm(5, mean = 0, sd = 5)

data_ext <- dplyr::bind_rows(
  data,
  data.frame(X = X_ext1, Y = Y_ext1),
  data.frame(X = X_ext2, Y = Y_ext2)
)

# Identifica min e max
extremos <- data_ext %>%
  dplyr::filter(
    X == min(X) | X == max(X) |
    Y == min(Y) | Y == max(Y)
  ) %>%
  dplyr::mutate(tipo = dplyr::case_when(
    X == min(X) ~ "X mínimo",
    X == max(X) ~ "X máximo",
    Y == min(Y) ~ "Y mínimo",
    Y == max(Y) ~ "Y máximo"
  ))

# Plot
ggplot2::ggplot(data_ext, ggplot2::aes(x = X, y = Y)) +
  # todos os pontos em cinza
  ggplot2::geom_point(color = "grey70", size = 2) +
  # destaca apenas os extremos, com legenda
  ggplot2::geom_point(data = extremos, ggplot2::aes(color = tipo), size = 3) +
  ggplot2::geom_smooth(method = "lm", se = FALSE, color = "blue") +
  ggplot2::scale_color_manual(values = c(
    "X mínimo" = "red",
    "X máximo" = "orange",
    "Y mínimo" = "purple",
    "Y máximo" = "darkgreen"
  )) +
  ggplot2::labs(
    title = "Valores extremos",
    x = "X", y = "Y", color = "Extremos"
  ) +
  ggplot2::theme_minimal()

```

<br>

## Robustez em medidas de localização

<br>

### O que é ponto de quebra (*breakdown value*)?

-   É a menor proporção de contaminação que pode levar o estimador a resultados arbitrariamente errados; quanto maior, mais robusto.[@rousseeuw2011]

<br>

### Por que a média não é robusta?

-   Porque tem ponto de quebra $~0%$ e função influência não limitada; um único *outlier* pode distorcer a média arbitrariamente.[@rousseeuw2011]

<br>

### Qual a alternativa robusta para localização?

-   Mediana, com $~50%$ de ponto de quebra e função influência limitada.[@rousseeuw2011]

<br>

### Como estimar escala de forma robusta?

-   Median Absolute Deviation (MAD), equação \@ref(eq:mad), com correção 1,483 para normalidade, com $~50%$ de ponto de quebra..[@rousseeuw2011]

<br>

```{=tex}
\begin{equation}
(\#eq:max)
MAD = 1.483 \cdot \text{median}(|x_i - \text{median}(x)|)
\end{equation}
```

<br>

- Primeiro quartil das diferenças pareadas ($Qn$), equação \@ref(eq:qn), com $~50%$ de ponto de quebra.[@rousseeuw2011]

<br>

```{=tex}
\begin{equation}
(\#eq:qn)
Qn = 2.2219 \cdot \text{first quartile}(|x_i - x_j|; i < j)
\end{equation}
```

<br>

-   O intervalo interquartil ($IQR$), equação \@ref(eq;iqr) é robusto, com ponto de quebra $~25%$, sendo simples de interpretar e útil em boxplots.[@rousseeuw2011]

<br>

```{=tex}
\begin{equation}
(\#eq:iqr)
IQR = Q3 - Q1
\end{equation}
```

<br>

## Parâmetros robustos

<br>

### O que são parâmetros robustos?

-   Parâmetros robustos são medidas de posição e dispersão que permanecem estáveis mesmo na presença de valores discrepantes.[@daszykowski2007]

<br>

### Que parâmetros robustos podem ser estimados?

-   Mediana em vez da média aritmética, pois é menos sensível a valores extremos.[@daszykowski2007]

-   MAD (Median Absolute Deviation) em vez do desvio padrão, que pode ser escalonado por 1.483 para comparabilidade.[@daszykowski2007]

-   Qn e Sn como estimadores alternativos de dispersão robusta.[@daszykowski2007]

-   Média e variância Winsorizadas como opções intermediárias, reduzindo a influência dos *outliers*.[@daszykowski2007]

<br>

### Por que utilizar parâmetros robustos?

-   Eles garantem maior confiabilidade quando os dados não seguem a normalidade ou apresentam contaminação por *outliers*.[@daszykowski2007]

-   Permitem análises mais estáveis em estudos exploratórios, evitando decisões equivocadas sobre variabilidade ou tendência central.[@daszykowski2007]

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
