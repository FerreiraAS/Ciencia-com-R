# **Apêndice - R scripts** {#apendice .unnumbered}

<br>

```{r, echo = FALSE, warning = FALSE, message = FALSE, results = 'asis'}
`%||%` <- function(x, y) if (is.null(x)) y else x

parse_rmd_to_rmd <- function(input_file,
                             output_file,
                             skip_last_chunk_in_chapter = TRUE) {
  rmd <- parsermd::parse_rmd(input_file)

  # --- 1) Captura do título do capítulo
  heading_idxs <- which(vapply(rmd, inherits, logical(1), "rmd_heading"))
  if (length(heading_idxs) == 0) stop("Nenhum heading encontrado no arquivo.")

  h1_pos <- which(vapply(rmd[heading_idxs], function(x) x$level == 1, logical(1)))[1]
  first_heading <- if (!is.na(h1_pos)) rmd[[heading_idxs[h1_pos]]] else rmd[[heading_idxs[1]]]

  heading_text <- first_heading$name %||% first_heading$label %||% ""
  chapter_title <- sub(".*\\*\\*(.*?)\\*\\*.*", "\\1", heading_text)
  if (identical(chapter_title, heading_text)) chapter_title <- heading_text

  con <- file(output_file, "w")
  on.exit(close(con), add = TRUE)

  writeLines(paste0("# ", chapter_title, " {.unnumbered .unlisted}\n"), con)

  # --- 2) Coletar todos os elementos que serão impressos
  output_items <- list()

  for (item in rmd) {
    if (inherits(item, "rmd_heading") && item$level == 2) {
      output_items <- c(output_items, list(list(type = "heading", text = item$name %||% item$label %||% "")))
    } else if (inherits(item, "rmd_chunk")) {
      output_items <- c(output_items, list(list(type = "chunk", chunk = item)))
    }
  }

  # --- 3) Se for para pular o último chunk do capítulo
  if (isTRUE(skip_last_chunk_in_chapter)) {
    chunk_positions <- which(vapply(output_items, function(x) x$type == "chunk", logical(1)))
    if (length(chunk_positions) > 0) {
      last_chunk_pos <- tail(chunk_positions, 1)
      output_items <- output_items[-last_chunk_pos]
    }
  }

  # --- 4) Escrever no arquivo
  for (el in output_items) {
    if (el$type == "heading") {
      writeLines(paste0("## ", el$text, " {.unnumbered .unlisted}\n"), con)
      writeLines("", con)
    } else if (el$type == "chunk") {
      chunk <- el$chunk
      engine <- chunk$engine %||% "r"
      writeLines(
        paste0(
          "```{", engine,
          " echo=TRUE, error=FALSE, warning=FALSE, message=FALSE, ",
          "results=FALSE, eval=FALSE, tidy='styler', tidy.opts=list(strict=FALSE)}"
        ),
        con
      )
      writeLines(chunk$code, con)
      writeLines("```", con)
      writeLines("", con)
    }
  }
}

# list files
files <- yaml::read_yaml("_bookdown.yml")$rmd_files

# filter pre and post textual files
remove <- c(
  "index.Rmd",
  "rmd/dedicatoria.Rmd",
  "rmd/agradecimentos.Rmd",
  "rmd/autor.Rmd",
  "rmd/prefacio.Rmd",
  "rmd/parte-1.Rmd",
  "rmd/parte-2.Rmd",
  "rmd/parte-3.Rmd",
  "rmd/parte-4.Rmd",
  "rmd/parte-5.Rmd",
  "rmd/parte-6.Rmd",
  "rmd/parte-7.Rmd",
  "rmd/parte-8.Rmd",
  "rmd/parte-9.Rmd",
  "rmd/parte-10.Rmd",
  "rmd/apendice.Rmd",
  "rmd/referencias.Rmd"
)
files <- files[!files %in% remove]

# Keep files that do have chunks and exist
files <- files[file.exists(files) & sapply(files, function(f) {
  rmd_content <- parsermd::parse_rmd(f)
  # Count chunks and check if the count is > 1
  sum(sapply(rmd_content, function(x) inherits(x, "rmd_chunk"))) > 1
})]

# Iterate through the filtered list of files
for (f in files) {
 # Generate filtered Rmd content
 parse_rmd_to_rmd(f, "rmd/apendice_temp.Rmd")

 # Include it in the output
 cat(knitr::knit_child("rmd/apendice_temp.Rmd", quiet = TRUE))
}

# Delete the temp Rmd (after render is complete)
unlink("rmd/apendice_temp.Rmd")
```

<br>

```{r, echo=FALSE, warning=FALSE, results='asis', eval=knitr::is_html_output()}
cat(readLines("citation.html"), sep = "\n")
```

<br>
