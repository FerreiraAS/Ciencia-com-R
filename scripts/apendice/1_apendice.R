`%||%` <- function(x, y) if (is.null(x)) y else x

parse_rmd_to_rmd <- function(input_file,
                             output_file,
                             skip_last_chunk_in_chapter = TRUE) {
  rmd <- parsermd::parse_rmd(input_file)

  # --- 1) Título do capítulo
  heading_idxs <- which(vapply(rmd, inherits, logical(1), "rmd_heading"))
  if (length(heading_idxs) == 0) stop("Nenhum heading encontrado no arquivo.")

  h1_pos <- which(vapply(rmd[heading_idxs], function(x) x$level == 1, logical(1)))[1]
  first_heading <- if (!is.na(h1_pos)) rmd[[heading_idxs[h1_pos]]] else rmd[[heading_idxs[1]]]

  heading_text <- first_heading$name %||% first_heading$label %||% ""
  chapter_title <- sub(".*\\*\\*(.*?)\\*\\*.*", "\\1", heading_text)
  if (identical(chapter_title, heading_text)) chapter_title <- heading_text

  con <- file(output_file, "w")
  on.exit(close(con), add = TRUE)

  # título do capítulo
  writeLines(paste0("# ", chapter_title, " {.unnumbered .unlisted}\n"), con)

  # --- 2) Agrupar conteúdo por seção (##)
  sections <- list()
  current_section <- NULL
  current_chunks <- list()

  flush_section <- function(title, chunks) {
    if (length(chunks) == 0) return(NULL)  # ignora se não há chunks
    list(title = title, chunks = chunks)
  }

  for (item in rmd) {
    if (inherits(item, "rmd_heading") && item$level == 2) {
      # salva a seção anterior (se houver chunks)
      if (!is.null(current_section)) {
        sections <- c(sections, list(flush_section(current_section, current_chunks)))
      }
      current_section <- item$name %||% item$label %||% ""
      current_chunks <- list()
    } else if (inherits(item, "rmd_chunk")) {
      # adiciona chunk à seção atual (se não houver seção, ignora)
      if (!is.null(current_section)) {
        current_chunks <- c(current_chunks, list(item))
      }
    }
  }
  # última seção
  if (!is.null(current_section)) {
    sections <- c(sections, list(flush_section(current_section, current_chunks)))
  }

  # remove NULLs (seções sem chunk)
  sections <- Filter(Negate(is.null), sections)

  # --- 3) Pular o último chunk do capítulo
  if (isTRUE(skip_last_chunk_in_chapter) && length(sections) > 0) {
    last_sec <- tail(sections, 1)[[1]]
    if (length(last_sec$chunks) > 0) {
      last_sec$chunks <- head(last_sec$chunks, -1)
    }
    sections[[length(sections)]] <- last_sec
  }

  # --- 4) Escrever as seções e seus chunks
  for (sec in sections) {
    writeLines(paste0("## ", sec$title, " {.unnumbered .unlisted}\n"), con)
    writeLines("", con)
    for (chunk in sec$chunks) {
      engine <- chunk$engine %||% "r"
      writeLines(
        paste0(
          "```{", engine,
          " echo=TRUE, error=FALSE, warning=FALSE, message=FALSE, ",
          "results=FALSE, eval=FALSE}"
        ),
        con
      )
      writeLines(chunk$code, con)
      writeLines("```", con)
      writeLines("", con)
    }
  }
}

# list files
files <- yaml::read_yaml("_bookdown.yml")$rmd_files

# filter pre and post textual files
remove <- c(
  "index.Rmd",
  "rmd/dedicatoria.Rmd",
  "rmd/agradecimentos.Rmd",
  "rmd/autor.Rmd",
  "rmd/prefacio.Rmd",
  "rmd/parte-1.Rmd",
  "rmd/parte-2.Rmd",
  "rmd/parte-3.Rmd",
  "rmd/parte-4.Rmd",
  "rmd/parte-5.Rmd",
  "rmd/parte-6.Rmd",
  "rmd/parte-7.Rmd",
  "rmd/parte-8.Rmd",
  "rmd/parte-9.Rmd",
  "rmd/parte-10.Rmd",
  "rmd/apendice.Rmd",
  "rmd/scripts.Rmd",
  "rmd/referencias.Rmd"
)
files <- files[!files %in% remove]

# Keep files that do have chunks and exist
files <- files[file.exists(files) & sapply(files, function(f) {
  rmd_content <- parsermd::parse_rmd(f)
  # Count chunks and check if the count is > 1
  sum(sapply(rmd_content, function(x) inherits(x, "rmd_chunk"))) > 1
})]

# Iterate through the filtered list of files
for (f in files) {
 # Generate filtered Rmd content
 parse_rmd_to_rmd(f, "rmd/apendice_temp.Rmd")

 # Include it in the output
 cat(knitr::knit_child("rmd/apendice_temp.Rmd", quiet = TRUE))
}

# Delete the temp Rmd (after render is complete)
unlink("rmd/apendice_temp.Rmd")
